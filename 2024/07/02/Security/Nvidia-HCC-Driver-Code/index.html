

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/world.png">
  <link rel="icon" href="/img/world.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#3e424a">
  <meta name="author" content="Jianliang·Shen">
  <meta name="keywords" content="">
  
    <meta name="description" content="Hopper GPU驱动代码CC部分分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="机密计算: HCC 驱动代码">
<meta property="og:url" content="http://yoursite.com/2024/07/02/Security/Nvidia-HCC-Driver-Code/index.html">
<meta property="og:site_name" content="TechOdyssey">
<meta property="og:description" content="Hopper GPU驱动代码CC部分分析。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/img/post_pics/HCC/hcc2_index.png">
<meta property="article:published_time" content="2024-07-02T14:43:10.000Z">
<meta property="article:modified_time" content="2024-07-30T16:39:00.419Z">
<meta property="article:author" content="Jianliang·Shen">
<meta property="article:tag" content="GPU">
<meta property="article:tag" content="TEE">
<meta property="article:tag" content="Confidential Compute">
<meta property="article:tag" content="Security">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yoursite.com/img/post_pics/HCC/hcc2_index.png">
  
  
  
  <title>机密计算: HCC 驱动代码 - TechOdyssey</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/icon.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":15,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tech Odyssey</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>Favor</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="https://vercel.com/jianliang-shens-projects" target="_self">
                    <i class="iconfont icon-vercel"></i>
                    <span>Vercel</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/pdf/" target="_self">
                    <i class="iconfont icon-pdf-new"></i>
                    <span>PDF</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://www.google.com/" target="_self">
                    <i class="iconfont icon-google-new"></i>
                    <span>Google</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://www.baidu.com/" target="_self">
                    <i class="iconfont icon-baidu-new"></i>
                    <span>Baidu</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://github.com/Jianliang-Shen" target="_self">
                    <i class="iconfont icon-github-new"></i>
                    <span>Github</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://www.zhihu.com" target="_self">
                    <i class="iconfont icon-zhihu-new"></i>
                    <span>Zhihu</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://www.bilibili.com/" target="_self">
                    <i class="iconfont icon-bilibili-new"></i>
                    <span>Bilibili</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://chat.openai.com/" target="_self">
                    <i class="iconfont icon-chatGPT"></i>
                    <span>Chatgpt</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://msdn.itellyou.cn/" target="_self">
                    <i class="iconfont icon-microsoft"></i>
                    <span>MSDN</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://www.iconfont.cn/" target="_self">
                    <i class="iconfont icon-iconfont"></i>
                    <span>Ali Icon</span>
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/back_1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="机密计算: HCC 驱动代码"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-02 14:43" pubdate>
          2024年7月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          98 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">机密计算: HCC 驱动代码</h1>
            
            
              <div class="markdown-body">
                
                <p>Hopper GPU驱动代码CC部分分析。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>535.43.02</p>
<p>新增了Hopper CC，主架构为H100<br>新增mbedtls和spdm库:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs txt">src/common/mebedtls<br><br>src/nvidia/generated/g_spdm_nvoc.c<br>src/nvidia/generated/g_spdm_nvoc.h<br><br>src/common/sdk/nvidia/inc/ctrl/ctrlcb33.h<br>src/common/sdk/nvidia/inc/class/clcb33.h<br><br>机密计算API ConfidentialComputeApi<br>src/nvidia/generated/g_conf_compute_api_nvoc.h<br>src/nvidia/generated/g_conf_compute_api_nvoc.c<br><br>src/nvidia/generated/g_conf_compute_nvoc.h<br>src/nvidia/generated/g_conf_compute_nvoc.c<br><br><br>src/nvidia/src/kernel/gpu/conf_compute/ccsl.c<br>src/nvidia/src/kernel/gpu/conf_compute/conf_compute_api.c<br>src/nvidia/src/kernel/gpu/conf_compute/conf_compute.c<br>src/nvidia/inc/kernel/gpu/conf_compute/conf_compute_keystore.h 密钥管理<br>src/nvidia/src/kernel/gpu/conf_compute/conf_compute_keystore.c<br>src/nvidia/src/kernel/gpu/conf_compute/arch/hopper/conf_compute_gh100.c<br>src/nvidia/src/kernel/gpu/conf_compute/arch/hopper/conf_compute_keystore_gh100.c<br><br><br>src/nvidia/inc/kernel/gpu/spdm/libspdm_includes.h<br>src/nvidia/inc/kernel/gpu/spdm/spdm.h<br><br>src\nvidia\src\kernel\gpu\mmu\arch\hopper\kern_gmmu_gh100.c (eb5c766)<br>src/nvidia/src/kernel/gpu/spdm/arch/hopper/spdm_gh100.c<br>src/nvidia/src/kernel/gpu/spdm/arch/hopper/spdm_module.c<br><br>src/nvidia/src/libraries/libspdm/2.3.1/<br>src/nvidia/src/libraries/libspdm/2.3.1/include/hal/library/cryptlib/<br></code></pre></td></tr></table></figure>

<!-- 判断是否开启CC mode:
gpuIsCCFeatureEnabled, gpuIsCCEnabledInHw_HAL
NvBool PDB_PROP_GPU_CC_FEATURE_CAPABLE; -->

<p>SEC2（Security Engine 2） 是一种集成在GPU或其他硬件中的安全模块，专门用于处理加密、解密和认证等安全操作。它通常用于确保数据在传输和存储过程中的机密性和完整性。<br>CSL（Crypto Security Layer）</p>
<h2 id="相关头文件"><a href="#相关头文件" class="headerlink" title="相关头文件"></a>相关头文件</h2><h3 id="nv-uvm-interface-h"><a href="#nv-uvm-interface-h" class="headerlink" title="nv_uvm_interface.h"></a>nv_uvm_interface.h</h3><p>kernel-open&#x2F;common&#x2F;inc&#x2F;nv_uvm_interface.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    CSL 接口和锁定</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    以下函数不获取 RM API 或 GPU 锁定，并且不能在不同线程中与相同的 UvmCslContext 参数同时调用。调用者必须保证这种排除。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    * nvUvmInterfaceCslLogDeviceEncryption</span><br><span class="hljs-comment">    * nvUvmInterfaceCslRotateIv</span><br><span class="hljs-comment">    * nvUvmInterfaceCslEncrypt</span><br><span class="hljs-comment">    * nvUvmInterfaceCslDecrypt</span><br><span class="hljs-comment">    * nvUvmInterfaceCslSign</span><br><span class="hljs-comment">    * nvUvmInterfaceCslQueryMessagePool</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceCslInitContext</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    为给定的安全通道分配并初始化 CSL 上下文。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    上下文的生命周期与其配对的安全通道的生命周期相同。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN/OUT] - CSL 上下文。</span><br><span class="hljs-comment">        channel[IN] - 安全通道句柄。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    错误代码：</span><br><span class="hljs-comment">        NV_ERR_INVALID_STATE - 系统未在机密计算模式下运行。</span><br><span class="hljs-comment">        NV_ERR_INVALID_CHANNEL - 关联通道不是安全通道。</span><br><span class="hljs-comment">        NV_ERR_IN_USE - 上下文已初始化。</span><br><span class="hljs-comment">*/</span><br>NV_STATUS <span class="hljs-title function_">nvUvmInterfaceCslInitContext</span><span class="hljs-params">(UvmCslContext *uvmCslContext,</span><br><span class="hljs-params">                                       uvmGpuChannelHandle channel)</span>;<br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceDeinitCslContext</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    安全地取消初始化并清除上下文的内容。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    如果上下文已取消初始化，则函数立即返回。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN] - CSL 上下文。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">nvUvmInterfaceDeinitCslContext</span><span class="hljs-params">(UvmCslContext *uvmCslContext)</span>;<br><br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceCslLogDeviceEncryption</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    返回一个 IV，稍后可在 nvUvmInterfaceCslEncrypt 方法中使用。IV 包含一个“freshness bit”，其</span><br><span class="hljs-comment">    值由此方法设置，随后由 nvUvmInterfaceCslEncrypt 弄脏，以防止 IV 的非恶意重用。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    有关锁定要求，请参阅“CSL 接口和锁定”。</span><br><span class="hljs-comment">    此函数不执行动态内存分配。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN/OUT] - CSL 上下文。</span><br><span class="hljs-comment">        encryptIv[OUT] - 设备加密成功之前存储的参数。它用作 nvUvmInterfaceCslEncrypt 的输入。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    错误代码：</span><br><span class="hljs-comment">        NV_ERR_INSUFFICIENT_RESOURCES - 新的 IV 会导致计数器溢出。</span><br><span class="hljs-comment">*/</span><br>NV_STATUS <span class="hljs-title function_">nvUvmInterfaceCslAcquireEncryptionIv</span><span class="hljs-params">(UvmCslContext *uvmCslContext,</span><br><span class="hljs-params">                                               UvmCslIv *encryptIv)</span>;<br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceCslLogDeviceEncryption</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    记录并检查有关设备加密的信息。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    有关锁定要求，请参阅“CSL 接口和锁定”。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    此函数不执行动态内存分配。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN/OUT] - CSL 上下文。</span><br><span class="hljs-comment">        decryptIv[OUT] - 设备加密成功之前存储的参数。它用作 nvUvmInterfaceCslDecrypt 的输入。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    错误代码：</span><br><span class="hljs-comment">        NV_ERR_INSUFFICIENT_RESOURCES - 设备加密会导致计数器溢出。</span><br><span class="hljs-comment">*/</span><br>NV_STATUS <span class="hljs-title function_">nvUvmInterfaceCslLogDeviceEncryption</span><span class="hljs-params">(UvmCslContext *uvmCslContext,</span><br><span class="hljs-params">                                               UvmCslIv *decryptIv)</span>;<br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceCslRotateIv</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    旋转给定通道和方向的 IV。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    此函数将在 CPU 和 GPU 上旋转 IV。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    应首先解密已由 GPU 加密的未完成消息，然后调用方向等于 UVM_CSL_DIR_GPU_TO_CPU 的此函数。</span><br><span class="hljs-comment">    同样，应首先解密已由 CPU 加密的未完成消息，然后调用方向等于 UVM_CSL_DIR_CPU_TO_GPU</span><br><span class="hljs-comment">    的此函数。对于给定方向，在调用此函数之前通道必须处于空闲状态。无论 IV 的消息计数器的值如何，</span><br><span class="hljs-comment">    都可以调用此函数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    有关锁定要求，请参阅“CSL 接口和锁定”。</span><br><span class="hljs-comment">    此函数不执行动态内存分配。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN/OUT] - CSL 上下文。</span><br><span class="hljs-comment">        direction[IN] - 任一</span><br><span class="hljs-comment">            - UVM_CSL_DIR_CPU_TO_GPU</span><br><span class="hljs-comment">            - UVM_CSL_DIR_GPU_TO_CPU</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    错误代码：</span><br><span class="hljs-comment">        NV_ERR_INSUFFICIENT_RESOURCES - 旋转操作会导致计数器溢出。</span><br><span class="hljs-comment">        NV_ERR_INVALID_ARGUMENT - 方向值无效。</span><br><span class="hljs-comment">*/</span><br>NV_STATUS <span class="hljs-title function_">nvUvmInterfaceCslRotateIv</span><span class="hljs-params">(UvmCslContext *uvmCslContext,</span><br><span class="hljs-params">                                    UvmCslDirection direction)</span>;<br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceCslEncrypt</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    加密数据并生成身份验证标签。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    身份验证、输入和输出缓冲区不得重叠。如果重叠，则调用此函数会产生未定义的行为。当输入和输出</span><br><span class="hljs-comment">    缓冲区按 16 字节对齐时，性能通常会最大化。这是 AES 块的自然对齐。</span><br><span class="hljs-comment">    encryptIV 可以从 nvUvmInterfaceCslAcquireEncryptionIv 获得。但是，它是可选的。如果</span><br><span class="hljs-comment">    它为 NULL，则将使用行中的下一个 IV。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    有关锁定要求，请参阅“CSL 接口和锁定”。</span><br><span class="hljs-comment">    此函数不执行动态内存分配。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN/OUT] - CSL 上下文。</span><br><span class="hljs-comment">        bufferSize[IN] - 输入和输出缓冲区的大小（以字节为单位）。值的范围可以从 1 字节到 (2^32) - 1 字节。</span><br><span class="hljs-comment">        inputBuffer[IN] - 明文输入缓冲区的地址。</span><br><span class="hljs-comment">        encryptIv[IN/OUT] - 用于加密的 IV。可以为 NULL。</span><br><span class="hljs-comment">        outputBuffer[OUT] - 密文输出缓冲区的地址。</span><br><span class="hljs-comment">        authTagBuffer[OUT] - 身份验证标签缓冲区的地址。其大小为 UVM_CSL_CRYPT_AUTH_TAG_SIZE_BYTES。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    错误代码：</span><br><span class="hljs-comment">        NV_ERR_INVALID_ARGUMENT </span><br><span class="hljs-comment">            - 数据大小为 0 字节。</span><br><span class="hljs-comment">            - encryptIv 已被使用。</span><br><span class="hljs-comment">*/</span><br>NV_STATUS <span class="hljs-title function_">nvUvmInterfaceCslEncrypt</span><span class="hljs-params">(UvmCslContext *uvmCslContext,</span><br><span class="hljs-params">                                   NvU32 bufferSize,</span><br><span class="hljs-params">                                   NvU8 <span class="hljs-type">const</span> *inputBuffer,</span><br><span class="hljs-params">                                   UvmCslIv *encryptIv,</span><br><span class="hljs-params">                                   NvU8 *outputBuffer,</span><br><span class="hljs-params">                                   NvU8 *authTagBuffer)</span>;<br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceCslDecrypt</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    验证身份验证标签并解密数据。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    身份验证、输入和输出缓冲区不得重叠。如果重叠，则调用此函数会产生未定义的行为。当输入和输出</span><br><span class="hljs-comment">    缓冲区按 16 字节对齐时，性能通常会最大化。这是 AES 块的自然对齐。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    有关锁定要求，请参阅“CSL 接口和锁定”。</span><br><span class="hljs-comment">    此函数不执行动态内存分配。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN/OUT] - CSL 上下文。</span><br><span class="hljs-comment">        bufferSize[IN] - 输入和输出缓冲区的大小（以字节为单位）。值的范围可以从 1 字节到 (2^32) - 1 字节。</span><br><span class="hljs-comment">        decryptIv[IN] - nvUvmInterfaceCslLogDeviceEncryption 给出的参数。</span><br><span class="hljs-comment">        inputBuffer[IN] - 密文输入缓冲区的地址。</span><br><span class="hljs-comment">        outputBuffer[OUT] - 明文输出缓冲区的地址。</span><br><span class="hljs-comment">        authTagBuffer[IN] - 身份验证标签缓冲区的地址。其大小为 UVM_CSL_CRYPT_AUTH_TAG_SIZE_BYTES。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    错误代码：</span><br><span class="hljs-comment">        NV_ERR_INSUFFICIENT_RESOURCES - 解密操作会导致计数器溢出。</span><br><span class="hljs-comment">        NV_ERR_INVALID_ARGUMENT - 数据大小为 0 字节。</span><br><span class="hljs-comment">        NV_ERR_INVALID_DATA - 身份验证标签验证失败。</span><br><span class="hljs-comment">*/</span><br>NV_STATUS <span class="hljs-title function_">nvUvmInterfaceCslDecrypt</span><span class="hljs-params">(UvmCslContext *uvmCslContext,</span><br><span class="hljs-params">                                   NvU32 bufferSize,</span><br><span class="hljs-params">                                   NvU8 <span class="hljs-type">const</span> *inputBuffer,</span><br><span class="hljs-params">                                   UvmCslIv <span class="hljs-type">const</span> *decryptIv,</span><br><span class="hljs-params">                                   NvU8 *outputBuffer,</span><br><span class="hljs-params">                                   NvU8 <span class="hljs-type">const</span> *authTagBuffer)</span>;<br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceCslSign</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    为安全工作启动生成身份验证标签。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    身份验证和输入缓冲区不得重叠。如果重叠，则调用此函数会产生未定义的行为。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    有关锁定要求，请参阅“CSL 接口和锁定”。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    此函数不执行动态内存分配。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN/OUT] - CSL 上下文。</span><br><span class="hljs-comment">        bufferSize[IN] - 输入缓冲区的大小（以字节为单位）。值的范围可以从 1 字节到 (2^32) - 1 字节。</span><br><span class="hljs-comment">        inputBuffer[IN] - 明文输入缓冲区的地址。</span><br><span class="hljs-comment">        authTagBuffer[OUT] - 身份验证标签缓冲区的地址。其大小为 UVM_CSL_SIGN_AUTH_TAG_SIZE_BYTES。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    错误代码：</span><br><span class="hljs-comment">        NV_ERR_INSUFFICIENT_RESOURCES - 签名操作会导致计数器溢出。</span><br><span class="hljs-comment">        NV_ERR_INVALID_ARGUMENT - 数据大小为 0 字节。</span><br><span class="hljs-comment">*/</span><br>NV_STATUS <span class="hljs-title function_">nvUvmInterfaceCslSign</span><span class="hljs-params">(UvmCslContext *uvmCslContext,</span><br><span class="hljs-params">                                NvU32 bufferSize,</span><br><span class="hljs-params">                                NvU8 <span class="hljs-type">const</span> *inputBuffer,</span><br><span class="hljs-params">                                NvU8 *authTagBuffer)</span>;<br><br><br><span class="hljs-comment">/*******************************************************************************</span><br><span class="hljs-comment">    nvUvmInterfaceCslQueryMessagePool</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    返回在消息计数器溢出之前可以加密的消息数量。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    有关锁定要求，请参阅“CSL 接口和锁定”。</span><br><span class="hljs-comment">    此函数不执行动态内存分配。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        uvmCslContext[IN/OUT] - CSL 上下文。</span><br><span class="hljs-comment">        direction[IN] - UVM_CSL_DIR_CPU_TO_GPU 或 UVM_CSL_DIR_GPU_TO_CPU。</span><br><span class="hljs-comment">        messageNum[OUT] - 溢出前剩余的消息数量。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    错误代码：</span><br><span class="hljs-comment">        NV_ERR_INVALID_ARGUMENT - direction 参数的值非法。</span><br><span class="hljs-comment">*/</span><br>NV_STATUS <span class="hljs-title function_">nvUvmInterfaceCslQueryMessagePool</span><span class="hljs-params">(UvmCslContext *uvmCslContext,</span><br><span class="hljs-params">                                            UvmCslDirection direction,</span><br><span class="hljs-params">                                            NvU64 *messageNum)</span>;<br></code></pre></td></tr></table></figure>

<h3 id="uvm-conf-computing-h"><a href="#uvm-conf-computing-h" class="headerlink" title="uvm_conf_computing.h"></a>uvm_conf_computing.h</h3><p>kernel-open&#x2F;nvidia-uvm&#x2F;uvm_conf_computing.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UVM_CONF_COMPUTING_AUTH_TAG_SIZE (UVM_CSL_CRYPT_AUTH_TAG_SIZE_BYTES)</span><br><br><span class="hljs-comment">// An authentication tag pointer is required by HW to be 16-bytes aligned.</span><br><span class="hljs-comment">// 硬件要求认证标签指针必须 16 字节对齐。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UVM_CONF_COMPUTING_AUTH_TAG_ALIGNMENT 16</span><br><br><span class="hljs-comment">// An IV pointer is required by HW to be 16-bytes aligned.</span><br><span class="hljs-comment">// HW 要求 IV 指针为 16 字节对齐。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Use sizeof(UvmCslIv) to refer to the IV size.</span><br><span class="hljs-comment">// 使用 sizeof(UvmCslIv) 来引用 IV 大小。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UVM_CONF_COMPUTING_IV_ALIGNMENT 16</span><br><br><span class="hljs-comment">// SEC2 decrypt operation buffers are required to be 16-bytes aligned. CE</span><br><span class="hljs-comment">// encrypt/decrypt can be unaligned if the buffer lies in a single 32B segment.</span><br><span class="hljs-comment">// Otherwise, they need to be 32B aligned.</span><br><span class="hljs-comment">// SEC2 解密操作缓冲区需要 16 字节对齐。如果缓冲区位于单个 32B 段中，则 CE 加密/解密可以</span><br><span class="hljs-comment">// 不对齐。否则，它们需要 32B 对齐。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UVM_CONF_COMPUTING_BUF_ALIGNMENT 32</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UVM_CONF_COMPUTING_DMA_BUFFER_SIZE UVM_VA_BLOCK_SIZE</span><br><br><span class="hljs-comment">// SEC2 supports at most a stream of 64 entries in the method stream for</span><br><span class="hljs-comment">// signing. Each entry is made of the method address and method data, therefore</span><br><span class="hljs-comment">// the maximum buffer size is: UVM_METHOD_SIZE * 2 * 64 = 512.</span><br><span class="hljs-comment">// UVM, however, won&#x27;t use this amount of entries, in the worst case scenario,</span><br><span class="hljs-comment">// we push a semaphore_releases or a decrypt. A SEC2 semaphore_release uses 6 1U</span><br><span class="hljs-comment">// entries, whereas a SEC2 decrypt uses 10 1U entries. For 10 entries,</span><br><span class="hljs-comment">// UVM_METHOD_SIZE * 2 * 10 = 80.</span><br><span class="hljs-comment">// SEC2 最多支持 64 个方法流条目进行签名。每个条目由方法地址和方法数据组成，因此最大缓冲区</span><br><span class="hljs-comment">// 大小为：UVM_METHOD_SIZE * 2 * 64 = 512。但是 UVM 不会使用这么多条目，在最坏的情况下，</span><br><span class="hljs-comment">// 我们会推送一个 semaphore_releases 或一个解密。SEC2 semaphore_release 使用 6 个</span><br><span class="hljs-comment">// 1U 条目，而 SEC2 解密使用 10 个 1U 条目。对于 10 个条目，UVM_METHOD_SIZE * 2 * 10 = 80。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UVM_CONF_COMPUTING_SIGN_BUF_MAX_SIZE 80</span><br><br><span class="hljs-comment">// All GPUs derive confidential computing status from their parent.</span><br><span class="hljs-comment">// By current policy all parent GPUs have identical confidential</span><br><span class="hljs-comment">// computing status.</span><br><span class="hljs-comment">// 所有 GPU 都从其父 GPU 获得机密计算状态。根据当前政策，所有父 GPU 都具有相同的机密计算状态。</span><br>NV_STATUS <span class="hljs-title function_">uvm_conf_computing_init_parent_gpu</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uvm_parent_gpu_t</span> *parent)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">uvm_conf_computing_mode_enabled_parent</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uvm_parent_gpu_t</span> *parent)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">uvm_conf_computing_mode_enabled</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uvm_gpu_t</span> *gpu)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">uvm_conf_computing_mode_is_hcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uvm_gpu_t</span> *gpu)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// List of free DMA buffers (uvm_conf_computing_dma_buffer_t).</span><br>    <span class="hljs-comment">// A free DMA buffer can be grabbed anytime, though the tracker</span><br>    <span class="hljs-comment">// inside it may still have pending work.</span><br>    <span class="hljs-comment">// 空闲 DMA 缓冲区列表（uvm_conf_computing_dma_buffer_t）。空闲的 DMA 缓冲区可以随时获取，但其中的跟踪器可能仍有待处理的工作。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">free_dma_buffers</span>;</span><br><br>    <span class="hljs-comment">// Used to grow the pool when full.</span><br>    <span class="hljs-comment">// 用于在池满时增大池子。</span><br>    <span class="hljs-type">size_t</span> num_dma_buffers;<br><br>    <span class="hljs-comment">// Lock protecting the dma_buffer_pool</span><br>    <span class="hljs-comment">// 保护 dma_buffer_pool 的锁</span><br>    <span class="hljs-type">uvm_mutex_t</span> lock;<br>&#125; <span class="hljs-type">uvm_conf_computing_dma_buffer_pool_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// Backing DMA allocation</span><br>    <span class="hljs-comment">// 支持 DMA 分配</span><br>    <span class="hljs-type">uvm_mem_t</span> *alloc;<br><br>    <span class="hljs-comment">// Used internally by the pool management code to track the state of</span><br>    <span class="hljs-comment">// a free buffer.</span><br>    <span class="hljs-comment">// 由池管理代码内部使用，以跟踪空闲缓冲区的状态。</span><br>    <span class="hljs-type">uvm_tracker_t</span> tracker;<br><br>    <span class="hljs-comment">// When the DMA buffer is used as the destination of a GPU encryption, SEC2</span><br>    <span class="hljs-comment">// writes the authentication tag here. Later when the buffer is decrypted</span><br>    <span class="hljs-comment">// on the CPU the authentication tag is used again (read) for CSL to verify</span><br>    <span class="hljs-comment">// the authenticity. The allocation is big enough for one authentication</span><br>    <span class="hljs-comment">// tag per PAGE_SIZE page in the alloc buffer.</span><br>    <span class="hljs-comment">// 当 DMA 缓冲区用作 GPU 加密的目标时，SEC2 会在此处写入身份验证标签。稍后，当缓冲区</span><br>    <span class="hljs-comment">// 在 CPU 上解密时，身份验证标签将再次用于（读取）CSL 以验证真实性。分配缓冲区中每个</span><br>    <span class="hljs-comment">// PAGE_SIZE 页的分配足够大，可以容纳一个身份验证标签。</span><br>    <span class="hljs-type">uvm_mem_t</span> *auth_tag;<br><br>    <span class="hljs-comment">// CSL supports out-of-order decryption, the decrypt IV is used similarly</span><br>    <span class="hljs-comment">// to the authentication tag. The allocation is big enough for one IV per</span><br>    <span class="hljs-comment">// PAGE_SIZE page in the alloc buffer. The granularity between the decrypt</span><br>    <span class="hljs-comment">// IV and authentication tag must match.</span><br>    <span class="hljs-comment">// CSL 支持无序解密，解密 IV 的使用方式与身份验证标签类似。分配缓冲区中每个 PAGE_SIZE</span><br>    <span class="hljs-comment">// 页的分配足够大，可以容纳一个 IV。解密 IV 和身份验证标签之间的粒度必须匹配。</span><br>    UvmCslIv decrypt_iv[(UVM_CONF_COMPUTING_DMA_BUFFER_SIZE / PAGE_SIZE)];<br><br>    <span class="hljs-comment">// 后备分配中的加密页面的位图</span><br>    <span class="hljs-type">uvm_page_mask_t</span> encrypted_page_mask;<br><br>    <span class="hljs-comment">// See uvm_conf_computing_dma_pool lists</span><br>    <span class="hljs-comment">// 参见 uvm_conf_computing_dma_pool 列表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span><br>&#125; <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span>;<br><br><span class="hljs-comment">// Retrieve a DMA buffer from the given DMA allocation pool.</span><br><span class="hljs-comment">// NV_OK                Stage buffer successfully retrieved</span><br><span class="hljs-comment">// NV_ERR_NO_MEMORY     No free DMA buffers are available for grab, and</span><br><span class="hljs-comment">//                      expanding the memory pool to get new ones failed.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// out_dma_buffer is only valid if NV_OK is returned. The caller is responsible</span><br><span class="hljs-comment">// for calling uvm_conf_computing_dma_buffer_free once the operations on this</span><br><span class="hljs-comment">// buffer are done.</span><br><span class="hljs-comment">// When out_tracker is passed to the function, the buffer&#x27;s dependencies are</span><br><span class="hljs-comment">// added to the tracker. The caller is guaranteed that all pending tracker</span><br><span class="hljs-comment">// entries come from the same GPU as the pool&#x27;s owner. Before being able to use</span><br><span class="hljs-comment">// the DMA buffer, the caller is responsible for either acquiring or waiting</span><br><span class="hljs-comment">// on out_tracker. If out_tracker is NULL, the wait happens in the allocation</span><br><span class="hljs-comment">// itself.</span><br><span class="hljs-comment">// Upon success the encrypted_page_mask is cleared as part of the allocation.</span><br><span class="hljs-comment">// 从给定的 DMA 分配池中检索 DMA 缓冲区。</span><br><span class="hljs-comment">//      NV_OK 阶段缓冲区已成功检索</span><br><span class="hljs-comment">//      NV_ERR_NO_MEMORY 没有可供抓取的空闲 DMA 缓冲区，扩展内存池以获取新缓冲区失败。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// out_dma_buffer 仅在返回 NV_OK 时才有效。调用者负责在完成此缓冲区上的操作后调用</span><br><span class="hljs-comment">// uvm_conf_computing_dma_buffer_free。</span><br><span class="hljs-comment">// 当 out_tracker 传递给函数时，缓冲区的依赖项将添加到跟踪器。调用者保证所有待处理的跟踪</span><br><span class="hljs-comment">// 器条目都来自与池所有者相同的 GPU。在能够使用 DMA 缓冲区之前，调用者负责获取或等待</span><br><span class="hljs-comment">// out_tracker。如果 out_tracker 为 NULL，则等待发生在分配本身中。</span><br><span class="hljs-comment">// 成功后，encrypted_pa​​ge_mask 将作为分配的一部分被清除。</span><br>NV_STATUS <span class="hljs-title function_">uvm_conf_computing_dma_buffer_alloc</span><span class="hljs-params">(<span class="hljs-type">uvm_conf_computing_dma_buffer_pool_t</span> *dma_buffer_pool,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> **out_dma_buffer,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_tracker_t</span> *out_tracker)</span>;<br><br><span class="hljs-comment">// Free a DMA buffer to the DMA allocation pool. All DMA buffers must be freed</span><br><span class="hljs-comment">// prior to GPU deinit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The tracker is optional and a NULL tracker indicates that no new operation</span><br><span class="hljs-comment">// has been pushed for the buffer. A non-NULL tracker indicates any additional</span><br><span class="hljs-comment">// pending operations on the buffer pushed by the caller that need to be</span><br><span class="hljs-comment">// synchronized before freeing or re-using the buffer.</span><br><span class="hljs-comment">// 将 DMA 缓冲区释放到 DMA 分配池。在 GPU 取消初始化之前，必须释放所有 DMA 缓冲区。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 跟踪器是可选的，NULL 跟踪器表示尚未为缓冲区推送任何新操作。非 NULL 跟踪器表示调用者推送</span><br><span class="hljs-comment">// 的缓冲区上任何其他待处理操作，这些操作需要在释放或重新使用缓冲区之前进行同步。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_conf_computing_dma_buffer_free</span><span class="hljs-params">(<span class="hljs-type">uvm_conf_computing_dma_buffer_pool_t</span> *dma_buffer_pool,</span><br><span class="hljs-params">                                        <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer,</span><br><span class="hljs-params">                                        <span class="hljs-type">uvm_tracker_t</span> *tracker)</span>;<br><br><span class="hljs-comment">// Synchronize trackers in all entries in the GPU&#x27;s DMA pool</span><br><span class="hljs-comment">// 同步 GPU 的 DMA 池中的所有条目中的跟踪器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_conf_computing_dma_buffer_pool_sync</span><span class="hljs-params">(<span class="hljs-type">uvm_conf_computing_dma_buffer_pool_t</span> *dma_buffer_pool)</span>;<br><br><br><span class="hljs-comment">// Initialization and deinitialization of Confidential Computing data structures</span><br><span class="hljs-comment">// for the given GPU.</span><br><span class="hljs-comment">// 初始化和取消初始化给定 GPU 的机密计算数据结构。</span><br>NV_STATUS <span class="hljs-title function_">uvm_conf_computing_gpu_init</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_conf_computing_gpu_deinit</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu)</span>;<br><br><span class="hljs-comment">// Logs encryption information from the GPU and returns the IV.</span><br><span class="hljs-comment">// 记录来自 GPU 的加密信息并返回 IV。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_conf_computing_log_gpu_encryption</span><span class="hljs-params">(<span class="hljs-type">uvm_channel_t</span> *channel, UvmCslIv *iv)</span>;<br><br><span class="hljs-comment">// Acquires next CPU encryption IV and returns it.</span><br><span class="hljs-comment">// 获取下一个CPU加密IV并返回。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_conf_computing_acquire_encryption_iv</span><span class="hljs-params">(<span class="hljs-type">uvm_channel_t</span> *channel, UvmCslIv *iv)</span>;<br><br><span class="hljs-comment">// CPU side encryption helper with explicit IV, which is obtained from</span><br><span class="hljs-comment">// uvm_conf_computing_acquire_encryption_iv. Without an explicit IV</span><br><span class="hljs-comment">// the function uses the next IV in order. Encrypts data in src_plain and</span><br><span class="hljs-comment">// write the cipher text in dst_cipher. src_plain and dst_cipher can&#x27;t overlap.</span><br><span class="hljs-comment">// The IV is invalidated and can&#x27;t be used again after this operation.</span><br><span class="hljs-comment">// CPU 端加密辅助程序，具有显式 IV，可从 uvm_conf_computing_acquire_encryption_iv 获取。</span><br><span class="hljs-comment">// 如果没有显式 IV，该函数将按顺序使用下一个 IV。加密 src_plain 中的数据并将密文写入</span><br><span class="hljs-comment">// dst_cipher。src_plain 和 dst_cipher 不能重叠。此操作后，IV 无效，无法再次使用。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_conf_computing_cpu_encrypt</span><span class="hljs-params">(<span class="hljs-type">uvm_channel_t</span> *channel,</span><br><span class="hljs-params">                                    <span class="hljs-type">void</span> *dst_cipher,</span><br><span class="hljs-params">                                    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src_plain,</span><br><span class="hljs-params">                                    UvmCslIv *encrypt_iv,</span><br><span class="hljs-params">                                    <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                    <span class="hljs-type">void</span> *auth_tag_buffer)</span><br>&#123;<br>    NV_STATUS status;<br><br>    UVM_ASSERT(size);<br><br>    uvm_mutex_lock(&amp;channel-&gt;csl.ctx_lock);<br>    status = nvUvmInterfaceCslEncrypt(&amp;channel-&gt;csl.ctx,<br>                                      size,<br>                                      (NvU8 <span class="hljs-type">const</span> *) src_plain,<br>                                      encrypt_iv,<br>                                      (NvU8 *) dst_cipher,<br>                                      (NvU8 *) auth_tag_buffer);<br>    uvm_mutex_unlock(&amp;channel-&gt;csl.ctx_lock);<br><br>    <span class="hljs-comment">// nvUvmInterfaceCslEncrypt fails when a 64-bit encryption counter</span><br>    <span class="hljs-comment">// overflows. This is not supposed to happen on CC.</span><br>    UVM_ASSERT(status == NV_OK);<br>&#125;<br><br><span class="hljs-comment">// CPU side decryption helper. Decrypts data from src_cipher and writes the</span><br><span class="hljs-comment">// plain text in dst_plain. src_cipher and dst_plain can&#x27;t overlap. IV obtained</span><br><span class="hljs-comment">// from uvm_conf_computing_log_gpu_encryption() needs to be be passed to src_iv.</span><br><span class="hljs-comment">// CPU 端解密助手。从 src_cipher 解密数据并将纯文本写入 dst_plain。src_cipher 和</span><br><span class="hljs-comment">// dst_plain 不能重叠。从 uvm_conf_computing_log_gpu_encryption() 获得的 IV 需要传递给 src_iv。</span><br>NV_STATUS <span class="hljs-title function_">uvm_conf_computing_cpu_decrypt</span><span class="hljs-params">(<span class="hljs-type">uvm_channel_t</span> *channel,</span><br><span class="hljs-params">                                         <span class="hljs-type">void</span> *dst_plain,</span><br><span class="hljs-params">                                         <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src_cipher,</span><br><span class="hljs-params">                                         <span class="hljs-type">const</span> UvmCslIv *src_iv,</span><br><span class="hljs-params">                                         <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                         <span class="hljs-type">const</span> <span class="hljs-type">void</span> *auth_tag_buffer)</span><br>&#123;<br>    NV_STATUS status;<br><br>    uvm_mutex_lock(&amp;channel-&gt;csl.ctx_lock);<br>    status = nvUvmInterfaceCslDecrypt(&amp;channel-&gt;csl.ctx,<br>                                      size,<br>                                      (<span class="hljs-type">const</span> NvU8 *) src_cipher,<br>                                      src_iv,<br>                                      (NvU8 *) dst_plain,<br>                                      (<span class="hljs-type">const</span> NvU8 *) auth_tag_buffer);<br>    uvm_mutex_unlock(&amp;channel-&gt;csl.ctx_lock);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="nvrm-registry-h"><a href="#nvrm-registry-h" class="headerlink" title="nvrm_registry.h"></a>nvrm_registry.h</h3><p>src&#x2F;nvidia&#x2F;interface&#x2F;nvrm_registry.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Add the conditions to exclude these macros from Orin build, as CONFIDENTIAL_COMPUTE</span><br><span class="hljs-comment">// is a guardword. The #if could be removed when nvRmReg.h file is trimmed from Orin build.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Enable Disable Confidential Compute and control its various modes of operation</span><br><span class="hljs-comment">// 0 - Feature Disable</span><br><span class="hljs-comment">// 1 - Feature Enable</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 添加条件以从 Orin 构建中排除这些宏，因为 CONFIDENTIAL_COMPUTE 是一个保护字。当从 Orin 构建中修剪 nvRmReg.h 文件时，可以删除 #if。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 启用禁用机密计算并控制其各种操作模式</span><br><span class="hljs-comment">// 0 - 功能禁用</span><br><span class="hljs-comment">// 1 - 功能启用</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE                              <span class="hljs-string">&quot;RmConfidentialCompute&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_ENABLED                      0:0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_ENABLED_NO                   0x00000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_ENABLED_YES                  0x00000001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_DEV_MODE_ENABLED             1:1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_DEV_MODE_ENABLED_NO          0x00000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_DEV_MODE_ENABLED_YES         0x00000001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_GPUS_READY_CHECK             2:2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_GPUS_READY_CHECK_DISABLED    0x00000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONFIDENTIAL_COMPUTE_GPUS_READY_CHECK_ENABLED     0x00000001</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONF_COMPUTE_EARLY_INIT                            <span class="hljs-string">&quot;RmConfComputeEarlyInit&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONF_COMPUTE_EARLY_INIT_DISABLED                   0x00000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NV_REG_STR_RM_CONF_COMPUTE_EARLY_INIT_ENABLED                    0x00000001</span><br></code></pre></td></tr></table></figure>

<h3 id="uvm-hal-h"><a href="#uvm-hal-h" class="headerlink" title="uvm_hal.h"></a>uvm_hal.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_maxwell_sec2_init_noop</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_hopper_sec2_init</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push)</span>;<br><br><span class="hljs-comment">// Encrypts the contents of the source buffer into the destination buffer, up to</span><br><span class="hljs-comment">// the given size. The authentication tag of the encrypted contents is written</span><br><span class="hljs-comment">// to auth_tag, so it can be verified later on by a decrypt operation.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The addressing modes of the destination and authentication tag addresses</span><br><span class="hljs-comment">// should match. If the addressing mode is physical, then the address apertures</span><br><span class="hljs-comment">// should also match.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">uvm_hal_ce_encrypt_t</span>)</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                                     <span class="hljs-type">uvm_gpu_address_t</span> dst,</span><br><span class="hljs-params">                                     <span class="hljs-type">uvm_gpu_address_t</span> src,</span><br><span class="hljs-params">                                     NvU32 size,</span><br><span class="hljs-params">                                     <span class="hljs-type">uvm_gpu_address_t</span> auth_tag)</span>;<br><br><span class="hljs-comment">// Decrypts the contents of the source buffer into the destination buffer, up to</span><br><span class="hljs-comment">// the given size. The method also verifies the integrity of the encrypted</span><br><span class="hljs-comment">// buffer by calculating its authentication tag, and comparing it with the one</span><br><span class="hljs-comment">// provided as argument.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The addressing modes of the source and authentication tag addresses should</span><br><span class="hljs-comment">// match. If the addressing mode is physical, then the address apertures should</span><br><span class="hljs-comment">// also match.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">uvm_hal_ce_decrypt_t</span>)</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                                     <span class="hljs-type">uvm_gpu_address_t</span> dst,</span><br><span class="hljs-params">                                     <span class="hljs-type">uvm_gpu_address_t</span> src,</span><br><span class="hljs-params">                                     NvU32 size,</span><br><span class="hljs-params">                                     <span class="hljs-type">uvm_gpu_address_t</span> auth_tag)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_maxwell_ce_encrypt_unsupported</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                                            <span class="hljs-type">uvm_gpu_address_t</span> dst,</span><br><span class="hljs-params">                                            <span class="hljs-type">uvm_gpu_address_t</span> src,</span><br><span class="hljs-params">                                            NvU32 size,</span><br><span class="hljs-params">                                            <span class="hljs-type">uvm_gpu_address_t</span> auth_tag)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_maxwell_ce_decrypt_unsupported</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                                            <span class="hljs-type">uvm_gpu_address_t</span> dst,</span><br><span class="hljs-params">                                            <span class="hljs-type">uvm_gpu_address_t</span> src,</span><br><span class="hljs-params">                                            NvU32 size,</span><br><span class="hljs-params">                                            <span class="hljs-type">uvm_gpu_address_t</span> auth_tag)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_hopper_ce_encrypt</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> dst,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> src,</span><br><span class="hljs-params">                               NvU32 size,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> auth_tag)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_hopper_ce_decrypt</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> dst,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> src,</span><br><span class="hljs-params">                               NvU32 size,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> auth_tag)</span>;<br><br><span class="hljs-comment">// 源地址和目标地址必须是16字节对齐的。注意，最佳性能是在256字节对齐时实现的。解密大小必须大于0，并且是4字节的倍数。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 认证标签地址也必须是16字节对齐的。</span><br><span class="hljs-comment">// 认证标签缓冲区大小在uvm_conf_computing.h中定义为UVM_CONF_COMPUTING_AUTH_TAG_SIZE字节。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 将src缓冲区解密到给定大小的dst缓冲区中。</span><br><span class="hljs-comment">// 该方法还通过计算src缓冲区的认证标签并与提供的标签进行比较来验证其完整性。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 注意：SEC2不支持加密。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">uvm_hal_sec2_decrypt_t</span>)</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push, NvU64 dst_va, NvU64 src_va, NvU32 size, NvU64 auth_tag_va)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_maxwell_sec2_decrypt_unsupported</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                                              NvU64 dst_va,</span><br><span class="hljs-params">                                              NvU64 src_va,</span><br><span class="hljs-params">                                              NvU32 size,</span><br><span class="hljs-params">                                              NvU64 auth_tag_va)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_hopper_sec2_decrypt</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push, NvU64 dst_va, NvU64 src_va, NvU32 size, NvU64 auth_tag_va)</span>;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uvm_ce_hal_struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">uvm_hal_ce_memcopy_type_t</span> memcopy_copy_type;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">uvm_hal_ce_encrypt_t</span> encrypt;<br>    <span class="hljs-type">uvm_hal_ce_decrypt_t</span> decrypt;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uvm_sec2_hal_struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uvm_hal_init_t</span> init;<br>    <span class="hljs-type">uvm_hal_sec2_decrypt_t</span> decrypt;<br>    <span class="hljs-type">uvm_hal_semaphore_release_t</span> semaphore_release;<br>    <span class="hljs-type">uvm_hal_semaphore_timestamp_t</span> semaphore_timestamp;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// id is either a hardware class or GPU architecture</span><br>    NvU32 id;<br>    NvU32 parent_id;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-comment">// host_ops: id is a hardware class</span><br>        <span class="hljs-type">uvm_host_hal_t</span> host_ops;<br><br>        <span class="hljs-comment">// ce_ops: id is a hardware class</span><br>        <span class="hljs-type">uvm_ce_hal_t</span> ce_ops;<br><br>        <span class="hljs-comment">// arch_ops: id is an architecture</span><br>        <span class="hljs-type">uvm_arch_hal_t</span> arch_ops;<br><br>        <span class="hljs-comment">// fault_buffer_ops: id is an architecture</span><br>        <span class="hljs-type">uvm_fault_buffer_hal_t</span> fault_buffer_ops;<br><br>        <span class="hljs-comment">// access_counter_buffer_ops: id is an architecture</span><br>        <span class="hljs-type">uvm_access_counter_buffer_hal_t</span> access_counter_buffer_ops;<br><br>        <span class="hljs-comment">// sec2_ops: id is an architecture</span><br>        <span class="hljs-type">uvm_sec2_hal_t</span> sec2_ops;<br>    &#125; u;<br>&#125; <span class="hljs-type">uvm_hal_class_ops_t</span>;<br></code></pre></td></tr></table></figure>

<h4 id="Copy-Engine"><a href="#Copy-Engine" class="headerlink" title="Copy Engine"></a>Copy Engine</h4><p>uvm_hal.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Table for copy engine functions.</span><br><span class="hljs-comment">// Each entry is associated with a copy engine class through the &#x27;class&#x27; field.</span><br><span class="hljs-comment">// By setting the &#x27;parent_class&#x27; field, a class will inherit the parent class&#x27;s</span><br><span class="hljs-comment">// functions for any fields left NULL when uvm_hal_init_table() runs upon module</span><br><span class="hljs-comment">// load. The parent class must appear earlier in the array than the child.</span><br><span class="hljs-type">static</span> <span class="hljs-type">uvm_hal_class_ops_t</span> ce_table[] =<br>&#123;<br>    &#123;<br>        .id = MAXWELL_DMA_COPY_A,<br>        .u.ce_ops = &#123;<br>            <span class="hljs-comment">// ...</span><br>            .encrypt = uvm_hal_maxwell_ce_encrypt_unsupported,<br>            .decrypt = uvm_hal_maxwell_ce_decrypt_unsupported,<br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// ...</span><br>    &#123;<br>        .id = HOPPER_DMA_COPY_A,<br>        .parent_id = AMPERE_DMA_COPY_B,<br>        .u.ce_ops = &#123;<br>            <span class="hljs-comment">// ...</span><br>            .memcopy_copy_type = uvm_hal_hopper_ce_memcopy_copy_type,<br>            <span class="hljs-comment">// ...</span><br>            .encrypt = uvm_hal_hopper_ce_encrypt,<br>            .decrypt = uvm_hal_hopper_ce_decrypt,<br>        &#125;,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="C-program"><a href="#C-program" class="headerlink" title="C program"></a>C program</h2><h3 id="uvm-gpu-c-uvm-ioctl"><a href="#uvm-gpu-c-uvm-ioctl" class="headerlink" title="uvm_gpu.c: uvm_ioctl"></a>uvm_gpu.c: uvm_ioctl</h3><p>kernel-open&#x2F;nvidia-uvm&#x2F;uvm_gpu.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">uvm_ioctl()<br>--&gt; UVM_ROUTE_CMD_STACK_INIT_CHECK(UVM_REGISTER_GPU,                   uvm_api_register_gpu);<br>    --&gt; uvm_va_space_register_gpu()<br>        --&gt; uvm_gpu_retain_by_uuid()<br>            --&gt; gpu_retain_by_uuid_locked()<br>                --&gt; add_gpu()<br>                    --&gt; init_gpu()<br>                        --&gt; status = uvm_conf_computing_gpu_init(gpu);<br>                            <span class="hljs-comment">// Initialization and deinitialization of Confidential Computing data structures</span><br>                            <span class="hljs-comment">// for the given GPU.</span><br>                            <span class="hljs-keyword">if</span> (status != NV_OK) &#123;<br>                                UVM_ERR_PRINT(<span class="hljs-string">&quot;Failed to initialize Confidential Compute: %s for GPU %s\n&quot;</span>,<br>                                            nvstatusToString(status),<br>                                            uvm_gpu_name(gpu));<br>                                <span class="hljs-keyword">return</span> status;<br>                        &#125;<br></code></pre></td></tr></table></figure>

<h3 id="uvm-conf-computing-gpu-init"><a href="#uvm-conf-computing-gpu-init" class="headerlink" title="uvm_conf_computing_gpu_init"></a>uvm_conf_computing_gpu_init</h3><p>kernel-open&#x2F;nvidia-uvm&#x2F;uvm_conf_computing.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">NV_STATUS <span class="hljs-title function_">uvm_conf_computing_gpu_init</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu)</span><br>&#123;<br>    NV_STATUS status;<br><br>    <span class="hljs-keyword">if</span> (!uvm_conf_computing_mode_enabled(gpu))<br>        <span class="hljs-keyword">return</span> NV_OK;<br><br>    status = conf_computing_dma_buffer_pool_init(&amp;gpu-&gt;conf_computing.dma_buffer_pool);<br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">return</span> status;<br><br>    status = dummy_iv_mem_init(gpu);<br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">goto</span> error;<br><br>    <span class="hljs-keyword">return</span> NV_OK;<br><br>error:<br>    uvm_conf_computing_gpu_deinit(gpu);<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="uvm-conf-computing-mode-enabled"><a href="#uvm-conf-computing-mode-enabled" class="headerlink" title="uvm_conf_computing_mode_enabled"></a>uvm_conf_computing_mode_enabled</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">uvm_conf_computing_mode_enabled()<br>--&gt; <span class="hljs-keyword">return</span> uvm_conf_computing_get_mode(parent) != UVM_GU_CONF_COMPUTE_MODE_NONE;<br>    --&gt; <span class="hljs-keyword">return</span> parent-&gt;rm_info.gpuConfComputeCaps.mode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    UVM_GPU_CONF_COMPUTE_MODE_NONE,<br>    UVM_GPU_CONF_COMPUTE_MODE_APM,<br>    UVM_GPU_CONF_COMPUTE_MODE_HCC,<br>    UVM_GPU_CONF_COMPUTE_MODE_COUNT<br>&#125; UvmGpuConfComputeMode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UvmGpuInfo_tag</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// Confidential Compute capabilities of this GPU</span><br>    UvmGpuConfComputeCaps gpuConfComputeCaps;<br><br>    <span class="hljs-comment">// ...</span><br>&#125; UvmGpuInfo;<br><br>nvGpuOpsGetGpuInfo()<br>--&gt; status = nvGpuOpsQueryGpuConfidentialComputeCaps(clientHandle, &amp;pGpuInfo-&gt;gpuConfComputeCaps);<br><br><span class="hljs-type">static</span> NV_STATUS<br><span class="hljs-title function_">nvGpuOpsQueryGpuConfidentialComputeCaps</span><span class="hljs-params">(NvHandle hClient,</span><br><span class="hljs-params">                                        UvmGpuConfComputeCaps *pGpuConfComputeCaps)</span><br>&#123;<br>    NV_CONFIDENTIAL_COMPUTE_ALLOC_PARAMS confComputeAllocParams = &#123;<span class="hljs-number">0</span>&#125;;<br>    NV_CONF_COMPUTE_CTRL_CMD_SYSTEM_GET_CAPABILITIES_PARAMS confComputeParams = &#123;<span class="hljs-number">0</span>&#125;;<br>    RM_API *pRmApi = rmapiGetInterface(RMAPI_EXTERNAL_KERNEL);<br>    NvHandle hConfCompute = <span class="hljs-number">0</span>;<br>    NV_STATUS status = NV_OK;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">if</span> (confComputeParams.ccFeature == NV_CONF_COMPUTE_SYSTEM_FEATURE_APM_ENABLED)<br>    &#123;<br>        pGpuConfComputeCaps-&gt;mode = UVM_GPU_CONF_COMPUTE_MODE_APM;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (confComputeParams.ccFeature == NV_CONF_COMPUTE_SYSTEM_FEATURE_HCC_ENABLED)<br>    &#123;<br>        pGpuConfComputeCaps-&gt;mode = UVM_GPU_CONF_COMPUTE_MODE_HCC;<br>    &#125;<br><br>cleanup:<br>    pRmApi-&gt;Free(pRmApi, hClient, hConfCompute);<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="conf-computing-dma-buffer-pool-init"><a href="#conf-computing-dma-buffer-pool-init" class="headerlink" title="conf_computing_dma_buffer_pool_init"></a>conf_computing_dma_buffer_pool_init</h3><p>kernel-open&#x2F;nvidia-uvm&#x2F;uvm_conf_computing.c</p>
<p>Allocate and map a new DMA stage buffer to CPU and GPU (VA)<br>分配并映射新的 DMA 阶段缓冲区到 CPU 和 GPU（VA）<br>主体调用了 <code>dma_buffer_create()</code></p>
<h3 id="dma-buffer-create"><a href="#dma-buffer-create" class="headerlink" title="dma_buffer_create"></a>dma_buffer_create</h3><p>这段代码定义了一个静态函数 <code>dma_buffer_create</code>，用于分配并映射新的DMA缓冲区到CPU和GPU的虚拟地址空间。以下是对这段代码的详细分析：</p>
<h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">dma_buffer_create</span><span class="hljs-params">(<span class="hljs-type">uvm_conf_computing_dma_buffer_pool_t</span> *dma_buffer_pool,</span><br><span class="hljs-params">                                   <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> **dma_buffer_out)</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>dma_buffer_pool</code>：指向DMA缓冲区池的指针，用于管理DMA缓冲区的分配。</li>
<li><code>dma_buffer_out</code>：指向指针的指针，用于输出分配的DMA缓冲区。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li><code>NV_STATUS</code>：表示操作的状态，可以是成功（<code>NV_OK</code>）或失败（如<code>NV_ERR_NO_MEMORY</code>）。</li>
</ul>
</li>
</ul>
<h4 id="变量定义和初始化"><a href="#变量定义和初始化" class="headerlink" title="变量定义和初始化"></a>变量定义和初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uvm_gpu_t</span> *dma_owner;<br><span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer;<br><span class="hljs-type">uvm_mem_t</span> *alloc = <span class="hljs-literal">NULL</span>;<br>NV_STATUS status = NV_OK;<br><span class="hljs-type">size_t</span> auth_tags_size = (UVM_CONF_COMPUTING_DMA_BUFFER_SIZE / PAGE_SIZE) * UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>变量</strong>：<ul>
<li><code>dma_owner</code>：指向拥有DMA缓冲区的GPU。</li>
<li><code>dma_buffer</code>：指向DMA缓冲区的指针。</li>
<li><code>alloc</code>：指向内存分配结构的指针。</li>
<li><code>status</code>：表示操作状态，初始值为<code>NV_OK</code>。</li>
<li><code>auth_tags_size</code>：计算认证标签所需的内存大小。</li>
</ul>
</li>
</ul>
<h4 id="分配并初始化DMA缓冲区结构"><a href="#分配并初始化DMA缓冲区结构" class="headerlink" title="分配并初始化DMA缓冲区结构"></a>分配并初始化DMA缓冲区结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_buffer = uvm_kvmalloc_zero(<span class="hljs-keyword">sizeof</span>(*dma_buffer));<br><span class="hljs-keyword">if</span> (!dma_buffer)<br>    <span class="hljs-keyword">return</span> NV_ERR_NO_MEMORY;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>使用 <code>uvm_kvmalloc_zero</code> 分配并初始化DMA缓冲区结构。</li>
<li>如果分配失败，返回<code>NV_ERR_NO_MEMORY</code>。</li>
</ul>
</li>
</ul>
<h4 id="获取DMA缓冲区所有者并初始化相关结构"><a href="#获取DMA缓冲区所有者并初始化相关结构" class="headerlink" title="获取DMA缓冲区所有者并初始化相关结构"></a>获取DMA缓冲区所有者并初始化相关结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_owner = dma_buffer_pool_to_gpu(dma_buffer_pool);<br>uvm_tracker_init(&amp;dma_buffer-&gt;tracker);<br>INIT_LIST_HEAD(&amp;dma_buffer-&gt;node);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>通过 <code>dma_buffer_pool_to_gpu</code> 函数获取DMA缓冲区的所有者GPU。</li>
<li>初始化DMA缓冲区的追踪器和链表头。</li>
</ul>
</li>
</ul>
<h4 id="分配和映射DMA缓冲区到CPU内核空间"><a href="#分配和映射DMA缓冲区到CPU内核空间" class="headerlink" title="分配和映射DMA缓冲区到CPU内核空间"></a>分配和映射DMA缓冲区到CPU内核空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_mem_alloc_sysmem_dma_and_map_cpu_kernel(UVM_CONF_COMPUTING_DMA_BUFFER_SIZE, dma_owner, <span class="hljs-literal">NULL</span>, &amp;alloc);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">goto</span> err;<br><br>dma_buffer-&gt;alloc = alloc;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>调用 <code>uvm_mem_alloc_sysmem_dma_and_map_cpu_kernel</code> 分配系统内存并映射到CPU内核空间。</li>
<li>如果分配失败，跳转到错误处理部分。</li>
<li>将分配的内存指针赋值给 <code>dma_buffer-&gt;alloc</code>。</li>
</ul>
</li>
</ul>
<h4 id="将分配的内存映射到GPU内核空间"><a href="#将分配的内存映射到GPU内核空间" class="headerlink" title="将分配的内存映射到GPU内核空间"></a>将分配的内存映射到GPU内核空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_mem_map_gpu_kernel(alloc, dma_owner);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">goto</span> err;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>调用 <code>uvm_mem_map_gpu_kernel</code> 将分配的内存映射到GPU内核空间。</li>
<li>如果映射失败，跳转到错误处理部分。</li>
</ul>
</li>
</ul>
<h4 id="分配和映射认证标签内存到CPU内核空间"><a href="#分配和映射认证标签内存到CPU内核空间" class="headerlink" title="分配和映射认证标签内存到CPU内核空间"></a>分配和映射认证标签内存到CPU内核空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_mem_alloc_sysmem_dma_and_map_cpu_kernel(auth_tags_size, dma_owner, <span class="hljs-literal">NULL</span>, &amp;alloc);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">goto</span> err;<br><br>dma_buffer-&gt;auth_tag = alloc;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>分配用于认证标签的系统内存并映射到CPU内核空间。</li>
<li>如果分配失败，跳转到错误处理部分。</li>
<li>将分配的内存指针赋值给 <code>dma_buffer-&gt;auth_tag</code>。</li>
</ul>
</li>
</ul>
<h4 id="将认证标签内存映射到GPU内核空间"><a href="#将认证标签内存映射到GPU内核空间" class="headerlink" title="将认证标签内存映射到GPU内核空间"></a>将认证标签内存映射到GPU内核空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_mem_map_gpu_kernel(alloc, dma_owner);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">goto</span> err;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>将认证标签的内存映射到GPU内核空间。</li>
<li>如果映射失败，跳转到错误处理部分。</li>
</ul>
</li>
</ul>
<h4 id="成功分配并返回"><a href="#成功分配并返回" class="headerlink" title="成功分配并返回"></a>成功分配并返回</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">*dma_buffer_out = dma_buffer;<br><span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>将分配的DMA缓冲区指针赋值给输出参数 <code>dma_buffer_out</code>。</li>
<li>返回操作状态 <code>status</code>。</li>
</ul>
</li>
</ul>
<h4 id="错误处理部分"><a href="#错误处理部分" class="headerlink" title="错误处理部分"></a>错误处理部分</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">err:<br>dma_buffer_destroy_locked(dma_buffer_pool, dma_buffer);<br><span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>如果任何一步失败，跳转到错误处理部分，销毁已经分配的DMA缓冲区。</li>
<li>返回操作状态 <code>status</code>。</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这段代码的主要目的是分配并初始化一个新的DMA缓冲区，包括认证标签，确保缓冲区既映射到CPU内核空间，也映射到GPU内核空间。整个过程包括：</p>
<ol>
<li>分配DMA缓冲区结构。</li>
<li>初始化追踪器和链表头。</li>
<li>分配并映射DMA缓冲区到CPU和GPU。</li>
<li>分配并映射认证标签内存到CPU和GPU。</li>
<li>错误处理，确保在任何一步失败时都能清理已分配的资源。</li>
</ol>
<p>理解这段代码的工作原理，有助于确保在实际应用中正确使用和管理DMA缓冲区。</p>
<h3 id="dummy-iv-mem-init"><a href="#dummy-iv-mem-init" class="headerlink" title="dummy_iv_mem_init"></a>dummy_iv_mem_init</h3><p>这段代码的功能是为指定的GPU分配和映射用于存储初始化向量（IV）的内存。如果GPU处于特定的计算模式（例如HCC模式），则执行这些操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">dummy_iv_mem_init</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu)</span><br></code></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>gpu</strong>：指向表示GPU的结构体的指针。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li><strong>NV_STATUS</strong>：表示操作的状态，可以是<code>NV_OK</code>（成功）或其他错误代码。</li>
</ul>
<h4 id="检查GPU计算模式"><a href="#检查GPU计算模式" class="headerlink" title="检查GPU计算模式"></a>检查GPU计算模式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!uvm_conf_computing_mode_is_hcc(gpu))<br>    <span class="hljs-keyword">return</span> NV_OK;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>检查GPU是否处于特定的计算模式（例如HCC模式）。如果不处于该模式，则不需要进行任何初始化，直接返回成功状态<code>NV_OK</code>。</li>
</ul>
</li>
</ul>
<h4 id="分配系统内存用于初始化向量（IV）"><a href="#分配系统内存用于初始化向量（IV）" class="headerlink" title="分配系统内存用于初始化向量（IV）"></a>分配系统内存用于初始化向量（IV）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_mem_alloc_sysmem_dma(<span class="hljs-keyword">sizeof</span>(UvmCslIv), gpu, <span class="hljs-literal">NULL</span>, &amp;gpu-&gt;conf_computing.iv_mem);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>调用 <code>uvm_mem_alloc_sysmem_dma</code> 函数分配系统内存，并将其映射为DMA内存。</li>
<li>分配的内存大小为 <code>sizeof(UvmCslIv)</code>，存储在 <code>gpu-&gt;conf_computing.iv_mem</code> 中。</li>
<li>如果分配失败，返回相应的错误状态 <code>status</code>。</li>
</ul>
</li>
</ul>
<h4 id="将分配的内存映射到GPU内核空间-1"><a href="#将分配的内存映射到GPU内核空间-1" class="headerlink" title="将分配的内存映射到GPU内核空间"></a>将分配的内存映射到GPU内核空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_mem_map_gpu_kernel(gpu-&gt;conf_computing.iv_mem, gpu);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">goto</span> error;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>调用 <code>uvm_mem_map_gpu_kernel</code> 函数将分配的内存映射到GPU内核空间。</li>
<li>如果映射失败，跳转到错误处理部分 <code>error</code>。</li>
</ul>
</li>
</ul>
<h4 id="成功返回"><a href="#成功返回" class="headerlink" title="成功返回"></a>成功返回</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> NV_OK;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>如果所有操作都成功，返回 <code>NV_OK</code>，表示初始化成功。</li>
</ul>
</li>
</ul>
<h4 id="错误处理部分-1"><a href="#错误处理部分-1" class="headerlink" title="错误处理部分"></a>错误处理部分</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">error:<br>dummy_iv_mem_deinit(gpu);<br><span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>如果在内存分配或映射过程中发生错误，跳转到 <code>error</code> 标签。</li>
<li>调用 <code>dummy_iv_mem_deinit</code> 函数进行清理，释放已经分配的资源。</li>
<li>返回错误状态 <code>status</code>。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>检查GPU计算模式</strong>：如果GPU不处于特定计算模式，则直接返回成功状态。</li>
<li><strong>分配内存</strong>：尝试为初始化向量（IV）分配系统内存。如果分配失败，返回错误状态。</li>
<li><strong>映射内存</strong>：将分配的内存映射到GPU内核空间。如果映射失败，执行错误处理。</li>
<li><strong>错误处理</strong>：在发生错误时，清理已分配的资源并返回错误状态。</li>
</ol>
<p>这段代码的主要目的是在特定计算模式下为GPU初始化用于存储初始化向量（IV）的内存。通过检查计算模式、分配内存和映射内存，这个函数确保GPU能够正确处理中断向量。如果在任何步骤中发生错误，函数会清理已分配的资源，并返回相应的错误状态。理解这个流程有助于正确管理GPU资源和处理错误情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">dummy_iv_mem_init</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu)</span><br>&#123;<br>    NV_STATUS status;<br><br>    <span class="hljs-keyword">if</span> (!uvm_conf_computing_mode_is_hcc(gpu))<br>        <span class="hljs-keyword">return</span> NV_OK;<br><br>    status = uvm_mem_alloc_sysmem_dma(<span class="hljs-keyword">sizeof</span>(UvmCslIv), gpu, <span class="hljs-literal">NULL</span>, &amp;gpu-&gt;conf_computing.iv_mem);<br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">return</span> status;<br><br>    status = uvm_mem_map_gpu_kernel(gpu-&gt;conf_computing.iv_mem, gpu);<br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">goto</span> error;<br><br>    <span class="hljs-keyword">return</span> NV_OK;<br><br>error:<br>    dummy_iv_mem_deinit(gpu);<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uvm_gpu_struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uvm_parent_gpu_t</span> *parent;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-type">uvm_conf_computing_dma_buffer_pool_t</span> dma_buffer_pool;<br><br>        <span class="hljs-comment">// 在CE加密过程中用于存储IV内容的临时内存。</span><br>        <span class="hljs-comment">// 这个内存位置只有在CE通道之后才可用，</span><br>        <span class="hljs-comment">// 因为我们使用它们来写入分配所需的PTE（页表项）。</span><br>        <span class="hljs-comment">// 当需要物理地址来访问IV缓冲区时使用这个位置。</span><br>        <span class="hljs-comment">// 参考函数：uvm_hal_hopper_ce_encrypt()。</span><br>        <span class="hljs-type">uvm_mem_t</span> *iv_mem;<br><br>        <span class="hljs-comment">// 在CE加密过程中用于存储IV内容的临时内存。</span><br>        <span class="hljs-comment">// 由于`iv_mem`的限制，并且需要在通道初始化时使用此类缓冲区，</span><br>        <span class="hljs-comment">// 我们使用RM分配。</span><br>        <span class="hljs-comment">// 当需要虚拟地址来访问IV缓冲区时使用这个位置。</span><br>        <span class="hljs-comment">// 参考函数：uvm_hal_hopper_ce_encrypt()。</span><br>        <span class="hljs-type">uvm_rm_mem_t</span> *iv_rm_mem;<br>    &#125; conf_computing;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="uvm-va-block-c"><a href="#uvm-va-block-c" class="headerlink" title="uvm_va_block.c"></a>uvm_va_block.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">block_copy_push()<br>--&gt; conf_computing_block_copy_push_cpu_to_gpu() / conf_computing_block_copy_push_gpu_to_cpu()<br><br>block_copy_end_push()<br>--&gt; conf_computing_copy_pages_finish()<br><br>UVM_ROUTE_CMD_STACK_INIT_CHECK(UVM_TOOLS_READ_PROCESS_MEMORY,      uvm_api_tools_read_process_memory);<br>UVM_ROUTE_CMD_STACK_INIT_CHECK(UVM_TOOLS_WRITE_PROCESS_MEMORY,     uvm_api_tools_write_process_memory);<br>--&gt; tools_access_va_block()<br>    <span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">tools_access_va_block</span><span class="hljs-params">(<span class="hljs-type">uvm_va_block_t</span> *va_block,</span><br><span class="hljs-params">                                        <span class="hljs-type">uvm_va_block_context_t</span> *block_context,</span><br><span class="hljs-params">                                        NvU64 target_va,</span><br><span class="hljs-params">                                        NvU64 size,</span><br><span class="hljs-params">                                        <span class="hljs-type">bool</span> is_write,</span><br><span class="hljs-params">                                        <span class="hljs-type">uvm_mem_t</span> *stage_mem)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (is_write) &#123;<br>            <span class="hljs-keyword">return</span> UVM_VA_BLOCK_LOCK_RETRY(va_block,<br>                                        <span class="hljs-literal">NULL</span>,<br>                                        uvm_va_block_write_from_cpu(va_block, block_context, target_va, stage_mem, size));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> UVM_VA_BLOCK_LOCK_RETRY(va_block,<br>                                        <span class="hljs-literal">NULL</span>,<br>                                        uvm_va_block_read_to_cpu(va_block, stage_mem, target_va, size));<br><br>        &#125;<br>    &#125;<br><br>uvm_va_block_write_from_cpu()<br>--&gt; va_block_write_cpu_to_gpu()<br>    --&gt; encrypted_memcopy_cpu_to_gpu()<br>        --&gt; uvm_conf_computing_cpu_encrypt()<br><br>uvm_va_block_read_to_cpu()<br>--&gt; va_block_read_gpu_to_cpu()<br>    --&gt; encrypted_memcopy_gpu_to_cpu()<br>        --&gt; uvm_conf_computing_cpu_decrypt()<br></code></pre></td></tr></table></figure>

<h3 id="uvm-hal-hopper-ce-encrypt"><a href="#uvm-hal-hopper-ce-encrypt" class="headerlink" title="uvm_hal_hopper_ce_encrypt"></a>uvm_hal_hopper_ce_encrypt</h3><p>这段代码定义了一个函数 <code>uvm_hal_hopper_ce_encrypt</code>，用于在指定的GPU上执行加密操作。它将源地址的数据加密后存储到目标地址，并生成一个认证标签。以下是对这段代码的详细分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_hopper_ce_encrypt</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> dst,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> src,</span><br><span class="hljs-params">                               NvU32 size,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> auth_tag)</span><br></code></pre></td></tr></table></figure>

<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>push</strong>：指向用于推送命令的结构体。</li>
<li><strong>dst</strong>：目标地址，解密后的数据将存储在此地址。</li>
<li><strong>src</strong>：源地址，包含需要加密的数据。</li>
<li><strong>size</strong>：加密数据的大小，必须大于0且为4字节的倍数。</li>
<li><strong>auth_tag</strong>：认证标签的地址，用于验证源数据的完整性。</li>
</ul>
<h4 id="获取GPU和参数验证"><a href="#获取GPU和参数验证" class="headerlink" title="获取GPU和参数验证"></a>获取GPU和参数验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uvm_gpu_t</span> *gpu = uvm_push_get_gpu(push);<br><br>UVM_ASSERT(uvm_conf_computing_mode_is_hcc(gpu));<br>UVM_ASSERT(uvm_push_is_fake(push) || uvm_channel_is_secure(push-&gt;channel));<br>UVM_ASSERT(IS_ALIGNED(auth_tag.address, UVM_CONF_COMPUTING_AUTH_TAG_ALIGNMENT));<br><br><span class="hljs-keyword">if</span> (!src.is_virtual)<br>    UVM_ASSERT(src.aperture == UVM_APERTURE_VID);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>获取GPU</strong>：从 <code>push</code> 结构体中获取GPU指针。</li>
<li><strong>参数验证</strong>：<ul>
<li>确保GPU处于特定计算模式（例如HCC模式）。</li>
<li>确保 <code>push</code> 是虚拟的或通道是安全的。</li>
<li>确保认证标签地址是对齐的。</li>
<li>如果源地址不是虚拟地址，确保其光圈类型是 <code>UVM_APERTURE_VID</code>。</li>
</ul>
</li>
</ul>
<h4 id="目的地址和认证标签验证"><a href="#目的地址和认证标签验证" class="headerlink" title="目的地址和认证标签验证"></a>目的地址和认证标签验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">UVM_ASSERT(dst.is_virtual == auth_tag.is_virtual);<br><br><span class="hljs-keyword">if</span> (!dst.is_virtual) &#123;<br>    UVM_ASSERT(dst.aperture == UVM_APERTURE_SYS);<br>    UVM_ASSERT(auth_tag.aperture == UVM_APERTURE_SYS);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>验证地址模式</strong>：<ul>
<li>确保目标地址和认证标签的地址模式一致（都是虚拟或都是物理地址）。</li>
<li>如果目标地址不是虚拟地址，确保其光圈类型和认证标签的光圈类型都是 <code>UVM_APERTURE_SYS</code>。</li>
</ul>
</li>
</ul>
<h4 id="设置加密模式"><a href="#设置加密模式" class="headerlink" title="设置加密模式"></a>设置加密模式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">NV_PUSH_1U(C8B5, SET_SECURE_COPY_MODE, HWCONST(C8B5, SET_SECURE_COPY_MODE, MODE, ENCRYPT));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>通过 <code>NV_PUSH_1U</code> 设置安全复制模式为加密。</li>
</ul>
</li>
</ul>
<h4 id="设置认证标签和IV地址"><a href="#设置认证标签和IV地址" class="headerlink" title="设置认证标签和IV地址"></a>设置认证标签和IV地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">auth_tag_address_hi32 = HWVALUE(C8B5, SET_ENCRYPT_AUTH_TAG_ADDR_UPPER, UPPER, NvU64_HI32(auth_tag.address));<br>auth_tag_address_lo32 = HWVALUE(C8B5, SET_ENCRYPT_AUTH_TAG_ADDR_LOWER, LOWER, NvU64_LO32(auth_tag.address));<br><br>iv_address = encrypt_iv_address(push, dst);<br><br>iv_address_hi32 = HWVALUE(C8B5, SET_ENCRYPT_IV_ADDR_UPPER, UPPER, NvU64_HI32(iv_address));<br>iv_address_lo32 = HWVALUE(C8B5, SET_ENCRYPT_IV_ADDR_LOWER, LOWER, NvU64_LO32(iv_address));<br><br>NV_PUSH_4U(C8B5, SET_ENCRYPT_AUTH_TAG_ADDR_UPPER, auth_tag_address_hi32,<br>                     SET_ENCRYPT_AUTH_TAG_ADDR_LOWER, auth_tag_address_lo32,<br>                     SET_ENCRYPT_IV_ADDR_UPPER, iv_address_hi32,<br>                     SET_ENCRYPT_IV_ADDR_LOWER, iv_address_lo32);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>计算并设置认证标签的高32位和低32位地址。</li>
<li>计算初始化向量（IV）的地址。</li>
<li>计算并设置IV的高32位和低32位地址。</li>
<li>使用 <code>NV_PUSH_4U</code> 将这些地址推送到硬件寄存器。</li>
</ul>
</li>
</ul>
<h4 id="执行加密操作"><a href="#执行加密操作" class="headerlink" title="执行加密操作"></a>执行加密操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">encrypt_or_decrypt(push, dst, src, size);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>调用 <code>encrypt_or_decrypt</code> 函数执行实际的加密操作，将源地址的数据加密后存储到目标地址。</li>
</ul>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>函数 <code>uvm_hal_hopper_ce_encrypt</code> 主要执行以下步骤：</p>
<ol>
<li><strong>获取GPU和验证参数</strong>：确保GPU处于正确的模式，地址对齐，并且源和目标地址模式一致。</li>
<li><strong>设置加密模式</strong>：通过硬件寄存器设置加密模式。</li>
<li><strong>设置地址</strong>：计算并设置认证标签和IV的地址，将这些地址推送到硬件寄存器。</li>
<li><strong>执行加密</strong>：调用实际的加密函数，将源地址的数据加密后存储到目标地址。</li>
</ol>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">获取GPU和验证参数<br>    |<br>    v<br>设置加密模式<br>    |<br>    v<br>计算并设置认证标签地址和IV地址<br>    |<br>    v<br>执行加密操作<br></code></pre></td></tr></table></figure>

<p>通过这些步骤，该函数确保在GPU上安全高效地执行加密操作，并生成必要的认证标签以验证数据的完整性。</p>
<h3 id="uvm-hal-hopper-ce-decrypt"><a href="#uvm-hal-hopper-ce-decrypt" class="headerlink" title="uvm_hal_hopper_ce_decrypt"></a>uvm_hal_hopper_ce_decrypt</h3><p>这段代码定义了一个函数 <code>uvm_hal_hopper_ce_decrypt</code>，用于在指定的GPU上执行解密操作。它将源地址的数据解密后存储到目标地址，并验证源数据的完整性。以下是对这段代码的详细分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">uvm_hal_hopper_ce_decrypt</span><span class="hljs-params">(<span class="hljs-type">uvm_push_t</span> *push,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> dst,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> src,</span><br><span class="hljs-params">                               NvU32 size,</span><br><span class="hljs-params">                               <span class="hljs-type">uvm_gpu_address_t</span> auth_tag)</span><br></code></pre></td></tr></table></figure>

<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>push</strong>：指向用于推送命令的结构体。</li>
<li><strong>dst</strong>：目标地址，解密后的数据将存储在此地址。</li>
<li><strong>src</strong>：源地址，包含需要解密的数据。</li>
<li><strong>size</strong>：解密数据的大小，必须大于0且为4字节的倍数。</li>
<li><strong>auth_tag</strong>：认证标签的地址，用于验证源数据的完整性。</li>
</ul>
<h4 id="获取GPU和参数验证-1"><a href="#获取GPU和参数验证-1" class="headerlink" title="获取GPU和参数验证"></a>获取GPU和参数验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uvm_gpu_t</span> *gpu = uvm_push_get_gpu(push);<br><br>UVM_ASSERT(uvm_conf_computing_mode_is_hcc(gpu));<br>UVM_ASSERT(!push-&gt;channel || uvm_channel_is_secure(push-&gt;channel));<br>UVM_ASSERT(IS_ALIGNED(auth_tag.address, UVM_CONF_COMPUTING_AUTH_TAG_ALIGNMENT));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>获取GPU</strong>：从 <code>push</code> 结构体中获取GPU指针。</li>
<li><strong>参数验证</strong>：<ul>
<li>确保GPU处于特定计算模式（例如HCC模式）。</li>
<li>确保 <code>push</code> 没有通道或者通道是安全的。</li>
<li>确保认证标签地址是对齐的。</li>
</ul>
</li>
</ul>
<h4 id="源地址和认证标签验证"><a href="#源地址和认证标签验证" class="headerlink" title="源地址和认证标签验证"></a>源地址和认证标签验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">UVM_ASSERT(src.is_virtual == auth_tag.is_virtual);<br><br><span class="hljs-keyword">if</span> (!src.is_virtual) &#123;<br>    UVM_ASSERT(src.aperture == UVM_APERTURE_SYS);<br>    UVM_ASSERT(auth_tag.aperture == UVM_APERTURE_SYS);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>验证地址模式</strong>：<ul>
<li>确保源地址和认证标签的地址模式一致（都是虚拟或都是物理地址）。</li>
<li>如果源地址不是虚拟地址，确保其光圈类型和认证标签的光圈类型都是 <code>UVM_APERTURE_SYS</code>。</li>
</ul>
</li>
</ul>
<h4 id="目的地址验证"><a href="#目的地址验证" class="headerlink" title="目的地址验证"></a>目的地址验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!dst.is_virtual)<br>    UVM_ASSERT(dst.aperture == UVM_APERTURE_VID);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>验证目的地址</strong>：<ul>
<li>如果目标地址不是虚拟地址，确保其光圈类型是 <code>UVM_APERTURE_VID</code>。</li>
</ul>
</li>
</ul>
<h4 id="设置解密模式"><a href="#设置解密模式" class="headerlink" title="设置解密模式"></a>设置解密模式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">NV_PUSH_1U(C8B5, SET_SECURE_COPY_MODE, HWCONST(C8B5, SET_SECURE_COPY_MODE, MODE, DECRYPT));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>通过 <code>NV_PUSH_1U</code> 设置安全复制模式为解密。</li>
</ul>
</li>
</ul>
<h4 id="设置认证标签地址"><a href="#设置认证标签地址" class="headerlink" title="设置认证标签地址"></a>设置认证标签地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">auth_tag_address_hi32 = HWVALUE(C8B5, SET_DECRYPT_AUTH_TAG_COMPARE_ADDR_UPPER, UPPER, NvU64_HI32(auth_tag.address));<br>auth_tag_address_lo32 = HWVALUE(C8B5, SET_DECRYPT_AUTH_TAG_COMPARE_ADDR_LOWER, LOWER, NvU64_LO32(auth_tag.address));<br><br>NV_PUSH_2U(C8B5, SET_DECRYPT_AUTH_TAG_COMPARE_ADDR_UPPER, auth_tag_address_hi32,<br>                     SET_DECRYPT_AUTH_TAG_COMPARE_ADDR_LOWER, auth_tag_address_lo32);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>计算并设置认证标签的高32位和低32位地址。</li>
<li>使用 <code>NV_PUSH_2U</code> 将这些地址推送到硬件寄存器。</li>
</ul>
</li>
</ul>
<h4 id="执行解密操作"><a href="#执行解密操作" class="headerlink" title="执行解密操作"></a>执行解密操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">encrypt_or_decrypt(push, dst, src, size);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：<ul>
<li>调用 <code>encrypt_or_decrypt</code> 函数执行实际的解密操作，将源地址的数据解密后存储到目标地址。</li>
</ul>
</li>
</ul>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>函数 <code>uvm_hal_hopper_ce_decrypt</code> 主要执行以下步骤：</p>
<ol>
<li><strong>获取GPU和验证参数</strong>：确保GPU处于正确的模式，地址对齐，并且源和认证标签的地址模式一致。</li>
<li><strong>验证地址模式</strong>：确保源地址和认证标签的光圈类型一致，如果目标地址不是虚拟地址，验证其光圈类型。</li>
<li><strong>设置解密模式</strong>：通过硬件寄存器设置解密模式。</li>
<li><strong>设置认证标签地址</strong>：计算并设置认证标签的高32位和低32位地址，将这些地址推送到硬件寄存器。</li>
<li><strong>执行解密操作</strong>：调用实际的解密函数，将源地址的数据解密后存储到目标地址。</li>
</ol>
<h4 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs txt">获取GPU和验证参数<br>    |<br>    v<br>验证源地址和认证标签地址模式<br>    |<br>    v<br>验证目的地址模式<br>    |<br>    v<br>设置解密模式<br>    |<br>    v<br>计算并设置认证标签地址<br>    |<br>    v<br>执行解密操作<br></code></pre></td></tr></table></figure>

<p>通过这些步骤，该函数确保在GPU上安全高效地执行解密操作，并验证数据的完整性。</p>
<h3 id="uvm-va-block-c-conf-computing-block-copy-push-cpu-to-gpu"><a href="#uvm-va-block-c-conf-computing-block-copy-push-cpu-to-gpu" class="headerlink" title="uvm_va_block.c: conf_computing_block_copy_push_cpu_to_gpu"></a>uvm_va_block.c: conf_computing_block_copy_push_cpu_to_gpu</h3><p>该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gpu-&gt;parent-&gt;ce_hal-&gt;decrypt(push, dst_address, staging_buffer, PAGE_SIZE, auth_tag_buffer);<br></code></pre></td></tr></table></figure>

<p>调用了decrypt，间接调用了 <code>uvm_hal_hopper_ce_decrypt</code></p>
<p>kernel-open&#x2F;nvidia-uvm&#x2F;uvm_va_block.c</p>
<p>这个函数 <code>conf_computing_block_copy_push_cpu_to_gpu</code> 实现了在启用机密计算功能时，CPU 端页面加密和 GPU 端解密操作。它使用推送命令（push）在 GPU 上执行这些操作，并且 GPU 操作会遵守调用者先前在推送命令中设置的内存屏障（membar）。以下是对这段代码的详细分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">conf_computing_block_copy_push_cpu_to_gpu</span><span class="hljs-params">(<span class="hljs-type">uvm_va_block_t</span> *block,</span><br><span class="hljs-params">                                                      <span class="hljs-type">block_copy_state_t</span> *copy_state,</span><br><span class="hljs-params">                                                      <span class="hljs-type">uvm_va_block_region_t</span> region,</span><br><span class="hljs-params">                                                      <span class="hljs-type">uvm_push_t</span> *push)</span><br></code></pre></td></tr></table></figure>

<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>block</strong>：表示虚拟地址块的结构体指针。</li>
<li><strong>copy_state</strong>：表示块复制状态的结构体指针。</li>
<li><strong>region</strong>：表示虚拟地址块区域的结构体。</li>
<li><strong>push</strong>：用于推送命令的结构体指针。</li>
</ul>
<h4 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uvm_push_flag_t</span> membar_flag = <span class="hljs-number">0</span>;<br><span class="hljs-type">uvm_gpu_t</span> *gpu = uvm_push_get_gpu(push);<br><span class="hljs-type">uvm_page_index_t</span> page_index = region.first;<br><span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer = copy_state-&gt;dma_buffer;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">src_page</span> =</span> uvm_cpu_chunk_get_cpu_page(block, page_index);<br><span class="hljs-type">uvm_gpu_address_t</span> staging_buffer = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;alloc, gpu);<br><span class="hljs-type">uvm_gpu_address_t</span> auth_tag_buffer = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;auth_tag, gpu);<br><span class="hljs-type">char</span> *cpu_auth_tag_buffer = (<span class="hljs-type">char</span> *)uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;auth_tag) +<br>                                        (page_index * UVM_CONF_COMPUTING_AUTH_TAG_SIZE);<br><span class="hljs-type">uvm_gpu_address_t</span> dst_address = block_copy_get_address(block, &amp;copy_state-&gt;dst, page_index, gpu);<br><span class="hljs-type">char</span> *cpu_va_staging_buffer = (<span class="hljs-type">char</span> *)uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;alloc) + (page_index * PAGE_SIZE);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>初始化 GPU 和 DMA 缓冲区相关的变量</strong>。</li>
<li><strong>获取源页面、目标地址和认证标签的相关信息</strong>。</li>
</ul>
<h4 id="参数和状态验证"><a href="#参数和状态验证" class="headerlink" title="参数和状态验证"></a>参数和状态验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">UVM_ASSERT(UVM_ID_IS_CPU(copy_state-&gt;src.id));<br>UVM_ASSERT(UVM_ID_IS_GPU(copy_state-&gt;dst.id));<br>UVM_ASSERT(uvm_conf_computing_mode_enabled(gpu));<br>UVM_ASSERT(uvm_tracker_is_completed(&amp;block-&gt;tracker));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>验证源和目标是否为 CPU 和 GPU</strong>。</li>
<li><strong>确保 GPU 启用了机密计算模式</strong>。</li>
<li><strong>确保块追踪器已经完成</strong>。</li>
</ul>
<h4 id="调整缓冲区地址"><a href="#调整缓冲区地址" class="headerlink" title="调整缓冲区地址"></a>调整缓冲区地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">staging_buffer.address += page_index * PAGE_SIZE;<br>auth_tag_buffer.address += page_index * UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>根据页面索引调整 staging_buffer 和 auth_tag_buffer 的地址</strong>。</li>
</ul>
<h4 id="内存屏障标志设置"><a href="#内存屏障标志设置" class="headerlink" title="内存屏障标志设置"></a>内存屏障标志设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (uvm_push_get_and_reset_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_NONE))<br>    membar_flag = UVM_PUSH_FLAG_NEXT_MEMBAR_NONE;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uvm_push_get_and_reset_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_GPU))<br>    membar_flag = UVM_PUSH_FLAG_NEXT_MEMBAR_GPU;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>根据推送命令设置内存屏障标志</strong>。</li>
</ul>
<h4 id="循环处理每个页面"><a href="#循环处理每个页面" class="headerlink" title="循环处理每个页面"></a>循环处理每个页面</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">for_each_va_block_page_in_region(page_index, region) &#123;<br>    <span class="hljs-type">void</span> *src_cpu_virt_addr;<br><br>    UVM_ASSERT(src_page == uvm_cpu_chunk_get_cpu_page(block, page_index));<br><br>    src_cpu_virt_addr = kmap(src_page);<br>    uvm_conf_computing_cpu_encrypt(push-&gt;channel,<br>                                   cpu_va_staging_buffer,<br>                                   src_cpu_virt_addr,<br>                                   <span class="hljs-literal">NULL</span>,<br>                                   PAGE_SIZE,<br>                                   cpu_auth_tag_buffer);<br>    kunmap(src_page);<br><br>    <span class="hljs-keyword">if</span> (page_index &gt; region.first)<br>        uvm_push_set_flag(push, UVM_PUSH_FLAG_CE_NEXT_PIPELINED);<br><br>    <span class="hljs-keyword">if</span> (page_index &lt; (region.outer - <span class="hljs-number">1</span>))<br>        uvm_push_set_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_NONE);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (membar_flag)<br>        uvm_push_set_flag(push, membar_flag);<br><br>    gpu-&gt;parent-&gt;ce_hal-&gt;decrypt(push, dst_address, staging_buffer, PAGE_SIZE, auth_tag_buffer);<br><br>    src_page++;<br>    dst_address.address += PAGE_SIZE;<br>    cpu_va_staging_buffer += PAGE_SIZE;<br>    staging_buffer.address += PAGE_SIZE;<br>    cpu_auth_tag_buffer += UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br>    auth_tag_buffer.address += UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>循环处理区域内的每个页面</strong>。</li>
<li><strong>对每个页面进行 kmap 和 kunmap 操作</strong>。</li>
<li><strong>执行 CPU 端加密，并使用 GPU 端解密</strong>。</li>
</ul>
<h4 id="中文注释"><a href="#中文注释" class="headerlink" title="中文注释"></a>中文注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 当启用机密计算功能时，该函数执行 CPU 端页面加密和 GPU 端解密到 CPR。</span><br><span class="hljs-comment">// GPU 操作遵守调用者在推送命令中先前设置的内存屏障。</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">conf_computing_block_copy_push_cpu_to_gpu</span><span class="hljs-params">(<span class="hljs-type">uvm_va_block_t</span> *block,</span><br><span class="hljs-params">                                                      <span class="hljs-type">block_copy_state_t</span> *copy_state,</span><br><span class="hljs-params">                                                      <span class="hljs-type">uvm_va_block_region_t</span> region,</span><br><span class="hljs-params">                                                      <span class="hljs-type">uvm_push_t</span> *push)</span><br>&#123;<br>    <span class="hljs-type">uvm_push_flag_t</span> membar_flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uvm_gpu_t</span> *gpu = uvm_push_get_gpu(push);<br>    <span class="hljs-type">uvm_page_index_t</span> page_index = region.first;<br>    <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer = copy_state-&gt;dma_buffer;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">src_page</span> =</span> uvm_cpu_chunk_get_cpu_page(block, page_index);<br>    <span class="hljs-type">uvm_gpu_address_t</span> staging_buffer = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;alloc, gpu);<br>    <span class="hljs-type">uvm_gpu_address_t</span> auth_tag_buffer = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;auth_tag, gpu);<br>    <span class="hljs-type">char</span> *cpu_auth_tag_buffer = (<span class="hljs-type">char</span> *)uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;auth_tag) +<br>                                        (page_index * UVM_CONF_COMPUTING_AUTH_TAG_SIZE);<br>    <span class="hljs-type">uvm_gpu_address_t</span> dst_address = block_copy_get_address(block, &amp;copy_state-&gt;dst, page_index, gpu);<br>    <span class="hljs-type">char</span> *cpu_va_staging_buffer = (<span class="hljs-type">char</span> *)uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;alloc) + (page_index * PAGE_SIZE);<br><br>    UVM_ASSERT(UVM_ID_IS_CPU(copy_state-&gt;src.id));<br>    UVM_ASSERT(UVM_ID_IS_GPU(copy_state-&gt;dst.id));<br><br>    UVM_ASSERT(uvm_conf_computing_mode_enabled(gpu));<br><br>    <span class="hljs-comment">// 参见 block_copy_begin_push 中的注释。</span><br>    UVM_ASSERT(uvm_tracker_is_completed(&amp;block-&gt;tracker));<br><br>    staging_buffer.address += page_index * PAGE_SIZE;<br>    auth_tag_buffer.address += page_index * UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br><br>    <span class="hljs-keyword">if</span> (uvm_push_get_and_reset_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_NONE))<br>        membar_flag = UVM_PUSH_FLAG_NEXT_MEMBAR_NONE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uvm_push_get_and_reset_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_GPU))<br>        membar_flag = UVM_PUSH_FLAG_NEXT_MEMBAR_GPU;<br><br>    <span class="hljs-comment">// kmap() 只保证 PAGE_SIZE 的连续性，所有加密和解密必须在 PAGE_SIZE 的基础上进行。</span><br>    for_each_va_block_page_in_region(page_index, region) &#123;<br>        <span class="hljs-type">void</span> *src_cpu_virt_addr;<br><br>        <span class="hljs-comment">// 调用者保证区域内的所有页面都是连续的，</span><br>        <span class="hljs-comment">// 这意味着它们被保证是同一个复合页面的一部分。</span><br>        UVM_ASSERT(src_page == uvm_cpu_chunk_get_cpu_page(block, page_index));<br><br>        src_cpu_virt_addr = kmap(src_page);<br>        uvm_conf_computing_cpu_encrypt(push-&gt;channel,<br>                                       cpu_va_staging_buffer,<br>                                       src_cpu_virt_addr,<br>                                       <span class="hljs-literal">NULL</span>,<br>                                       PAGE_SIZE,<br>                                       cpu_auth_tag_buffer);<br>        kunmap(src_page);<br><br>        <span class="hljs-comment">// 第一个 LCE 操作应该是非流水线的，以保证顺序，因为我们不知道上次非流水线复制的时间。</span><br>        <span class="hljs-comment">// 最后一个应用最初为推送计划的 membar（如果有的话）</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 3857691: 继承策略而不是强制第一次调用非流水线。</span><br>        <span class="hljs-keyword">if</span> (page_index &gt; region.first)<br>            uvm_push_set_flag(push, UVM_PUSH_FLAG_CE_NEXT_PIPELINED);<br><br>        <span class="hljs-keyword">if</span> (page_index &lt; (region.outer - <span class="hljs-number">1</span>))<br>            uvm_push_set_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_NONE);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (membar_flag)<br>            uvm_push_set_flag(push, membar_flag);<br><br>        gpu-&gt;parent-&gt;ce_hal-&gt;decrypt(push, dst_address, staging_buffer, PAGE_SIZE, auth_tag_buffer);<br><br>        src_page++;<br>        dst_address.address += PAGE_SIZE;<br>        cpu_va_staging_buffer += PAGE_SIZE;<br>        staging_buffer.address += PAGE_SIZE;<br>        cpu_auth_tag_buffer += UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br>        auth_tag_buffer.address += UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="uvm-va-block-c-conf-computing-block-copy-push-gpu-to-cpu"><a href="#uvm-va-block-c-conf-computing-block-copy-push-gpu-to-cpu" class="headerlink" title="uvm_va_block.c: conf_computing_block_copy_push_gpu_to_cpu"></a>uvm_va_block.c: conf_computing_block_copy_push_gpu_to_cpu</h3><p>该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gpu-&gt;parent-&gt;ce_hal-&gt;encrypt(push, staging_buffer, src_address, PAGE_SIZE, auth_tag_buffer);<br></code></pre></td></tr></table></figure>

<p>调用了decrypt，间接调用了 <code>uvm_hal_hopper_ce_encrypt</code></p>
<p>这个函数 <code>conf_computing_block_copy_push_gpu_to_cpu</code> 实现了在启用机密计算功能时，GPU 端页面加密和 CPU 端解密操作。它使用推送命令（push）在 GPU 上执行这些操作，并且 GPU 操作会遵守调用者先前在推送命令中设置的内存屏障（membar）。以下是对这段代码的详细分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">conf_computing_block_copy_push_gpu_to_cpu</span><span class="hljs-params">(<span class="hljs-type">uvm_va_block_t</span> *block,</span><br><span class="hljs-params">                                                      <span class="hljs-type">block_copy_state_t</span> *copy_state,</span><br><span class="hljs-params">                                                      <span class="hljs-type">uvm_va_block_region_t</span> region,</span><br><span class="hljs-params">                                                      <span class="hljs-type">uvm_push_t</span> *push)</span><br></code></pre></td></tr></table></figure>

<h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>block</strong>：表示虚拟地址块的结构体指针。</li>
<li><strong>copy_state</strong>：表示块复制状态的结构体指针。</li>
<li><strong>region</strong>：表示虚拟地址块区域的结构体。</li>
<li><strong>push</strong>：用于推送命令的结构体指针。</li>
</ul>
<h4 id="初始化变量-1"><a href="#初始化变量-1" class="headerlink" title="初始化变量"></a>初始化变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uvm_push_flag_t</span> membar_flag = <span class="hljs-number">0</span>;<br><span class="hljs-type">uvm_gpu_t</span> *gpu = uvm_push_get_gpu(push);<br><span class="hljs-type">uvm_page_index_t</span> page_index = region.first;<br><span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer = copy_state-&gt;dma_buffer;<br><span class="hljs-type">uvm_gpu_address_t</span> staging_buffer = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;alloc, gpu);<br><span class="hljs-type">uvm_gpu_address_t</span> auth_tag_buffer = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;auth_tag, gpu);<br><span class="hljs-type">uvm_gpu_address_t</span> src_address = block_copy_get_address(block, &amp;copy_state-&gt;src, page_index, gpu);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>初始化 GPU 和 DMA 缓冲区相关的变量</strong>。</li>
<li><strong>获取源地址和认证标签的相关信息</strong>。</li>
</ul>
<h4 id="参数和状态验证-1"><a href="#参数和状态验证-1" class="headerlink" title="参数和状态验证"></a>参数和状态验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">UVM_ASSERT(UVM_ID_IS_GPU(copy_state-&gt;src.id));<br>UVM_ASSERT(UVM_ID_IS_CPU(copy_state-&gt;dst.id));<br><br>UVM_ASSERT(uvm_conf_computing_mode_enabled(gpu));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>验证源和目标是否为 GPU 和 CPU</strong>。</li>
<li><strong>确保 GPU 启用了机密计算模式</strong>。</li>
</ul>
<h4 id="调整缓冲区地址-1"><a href="#调整缓冲区地址-1" class="headerlink" title="调整缓冲区地址"></a>调整缓冲区地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">staging_buffer.address += page_index * PAGE_SIZE;<br>auth_tag_buffer.address += page_index * UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>根据页面索引调整 staging_buffer 和 auth_tag_buffer 的地址</strong>。</li>
</ul>
<h4 id="内存屏障标志设置-1"><a href="#内存屏障标志设置-1" class="headerlink" title="内存屏障标志设置"></a>内存屏障标志设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (uvm_push_get_and_reset_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_NONE))<br>    membar_flag = UVM_PUSH_FLAG_NEXT_MEMBAR_NONE;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uvm_push_get_and_reset_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_GPU))<br>    membar_flag = UVM_PUSH_FLAG_NEXT_MEMBAR_GPU;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>根据推送命令设置内存屏障标志</strong>。</li>
</ul>
<h4 id="循环处理每个页面-1"><a href="#循环处理每个页面-1" class="headerlink" title="循环处理每个页面"></a>循环处理每个页面</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 由于我们使用 kmap() 映射用于 CPU 端加密操作的页面，它只保证 PAGE_SIZE 的连续性，</span><br><span class="hljs-comment">// 所有加密和解密操作必须在 PAGE_SIZE 基础上进行。</span><br>for_each_va_block_page_in_region(page_index, region) &#123;<br>    uvm_conf_computing_log_gpu_encryption(push-&gt;channel, &amp;dma_buffer-&gt;decrypt_iv[page_index]);<br><br>    <span class="hljs-comment">// 第一个 LCE 操作应该是非流水线的，以保证顺序，因为我们不知道上次非流水线复制的时间。</span><br>    <span class="hljs-comment">// 最后一个应用最初为推送计划的 membar（如果有的话）</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 3857691: 继承策略而不是强制第一次调用非流水线。</span><br>    <span class="hljs-keyword">if</span> (page_index &gt; region.first)<br>        uvm_push_set_flag(push, UVM_PUSH_FLAG_CE_NEXT_PIPELINED);<br><br>    <span class="hljs-keyword">if</span> (page_index &lt; (region.outer - <span class="hljs-number">1</span>))<br>        uvm_push_set_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_NONE);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (membar_flag)<br>        uvm_push_set_flag(push, membar_flag);<br><br>    gpu-&gt;parent-&gt;ce_hal-&gt;encrypt(push, staging_buffer, src_address, PAGE_SIZE, auth_tag_buffer);<br><br>    src_address.address += PAGE_SIZE;<br>    staging_buffer.address += PAGE_SIZE;<br>    auth_tag_buffer.address += UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>循环处理区域内的每个页面</strong>。</li>
<li><strong>记录 GPU 加密操作</strong>。</li>
<li><strong>执行 GPU 端加密操作，并根据页面索引调整地址和认证标签地址</strong>。</li>
</ul>
<h4 id="填充已加密页面掩码"><a href="#填充已加密页面掩码" class="headerlink" title="填充已加密页面掩码"></a>填充已加密页面掩码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">uvm_page_mask_region_fill(&amp;dma_buffer-&gt;encrypted_page_mask, region);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>更新 DMA 缓冲区中的已加密页面掩码</strong>。</li>
</ul>
<h4 id="中文注释-1"><a href="#中文注释-1" class="headerlink" title="中文注释"></a>中文注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 当启用机密计算功能时，该函数执行 GPU 端页面加密。GPU 操作遵守调用者在推送命令中先前设置的内存屏障。</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">conf_computing_block_copy_push_gpu_to_cpu</span><span class="hljs-params">(<span class="hljs-type">uvm_va_block_t</span> *block,</span><br><span class="hljs-params">                                                      <span class="hljs-type">block_copy_state_t</span> *copy_state,</span><br><span class="hljs-params">                                                      <span class="hljs-type">uvm_va_block_region_t</span> region,</span><br><span class="hljs-params">                                                      <span class="hljs-type">uvm_push_t</span> *push)</span><br>&#123;<br>    <span class="hljs-type">uvm_push_flag_t</span> membar_flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uvm_gpu_t</span> *gpu = uvm_push_get_gpu(push);<br>    <span class="hljs-type">uvm_page_index_t</span> page_index = region.first;<br>    <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer = copy_state-&gt;dma_buffer;<br>    <span class="hljs-type">uvm_gpu_address_t</span> staging_buffer = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;alloc, gpu);<br>    <span class="hljs-type">uvm_gpu_address_t</span> auth_tag_buffer = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;auth_tag, gpu);<br>    <span class="hljs-type">uvm_gpu_address_t</span> src_address = block_copy_get_address(block, &amp;copy_state-&gt;src, page_index, gpu);<br><br>    UVM_ASSERT(UVM_ID_IS_GPU(copy_state-&gt;src.id));<br>    UVM_ASSERT(UVM_ID_IS_CPU(copy_state-&gt;dst.id));<br><br>    UVM_ASSERT(uvm_conf_computing_mode_enabled(gpu));<br><br>    staging_buffer.address += page_index * PAGE_SIZE;<br>    auth_tag_buffer.address += page_index * UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br><br>    <span class="hljs-keyword">if</span> (uvm_push_get_and_reset_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_NONE))<br>        membar_flag = UVM_PUSH_FLAG_NEXT_MEMBAR_NONE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uvm_push_get_and_reset_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_GPU))<br>        membar_flag = UVM_PUSH_FLAG_NEXT_MEMBAR_GPU;<br><br>    <span class="hljs-comment">// 由于我们使用 kmap() 映射用于 CPU 端加密操作的页面，它只保证 PAGE_SIZE 的连续性，</span><br>    <span class="hljs-comment">// 所有加密和解密操作必须在 PAGE_SIZE 基础上进行。</span><br>    for_each_va_block_page_in_region(page_index, region) &#123;<br>        uvm_conf_computing_log_gpu_encryption(push-&gt;channel, &amp;dma_buffer-&gt;decrypt_iv[page_index]);<br><br>        <span class="hljs-comment">// 第一个 LCE 操作应该是非流水线的，以保证顺序，因为我们不知道上次非流水线复制的时间。</span><br>        <span class="hljs-comment">// 最后一个应用最初为推送计划的 membar（如果有的话）</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 3857691: 继承策略而不是强制第一次调用非流水线。</span><br>        <span class="hljs-keyword">if</span> (page_index &gt; region.first)<br>            uvm_push_set_flag(push, UVM_PUSH_FLAG_CE_NEXT_PIPELINED);<br><br>        <span class="hljs-keyword">if</span> (page_index &lt; (region.outer - <span class="hljs-number">1</span>))<br>            uvm_push_set_flag(push, UVM_PUSH_FLAG_NEXT_MEMBAR_NONE);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (membar_flag)<br>            uvm_push_set_flag(push, membar_flag);<br><br>        gpu-&gt;parent-&gt;ce_hal-&gt;encrypt(push, staging_buffer, src_address, PAGE_SIZE, auth_tag_buffer);<br><br>        src_address.address += PAGE_SIZE;<br>        staging_buffer.address += PAGE_SIZE;<br>        auth_tag_buffer.address += UVM_CONF_COMPUTING_AUTH_TAG_SIZE;<br>    &#125;<br><br>    uvm_page_mask_region_fill(&amp;dma_buffer-&gt;encrypted_page_mask, region);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>函数 <code>conf_computing_block_copy_push_gpu_to_cpu</code> 实现了在启用机密计算功能时，GPU 端页面加密的过程。通过初始化变量和验证参数，函数确保 GPU 和 CPU 间的数据传输和加密操作的正确性。通过处理区域内的每个页面，函数逐页执行加密操作，并更新相关的地址和认证标签地址。在完成所有页面的处理后，函数更新 DMA 缓冲区中的已加密页面掩码。</p>
<h3 id="uvm-va-block-c-conf-computing-copy-pages-finish"><a href="#uvm-va-block-c-conf-computing-copy-pages-finish" class="headerlink" title="uvm_va_block.c: conf_computing_copy_pages_finish"></a>uvm_va_block.c: conf_computing_copy_pages_finish</h3><p>这个函数 <code>conf_computing_copy_pages_finish</code> 负责完成机密计算中的页面复制操作。它在推送命令完成后，处理从GPU到CPU的页面数据传输，并在CPU端解密这些数据。以下是对这段代码的详细分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">conf_computing_copy_pages_finish</span><span class="hljs-params">(<span class="hljs-type">uvm_va_block_t</span> *block,</span><br><span class="hljs-params">                                                  <span class="hljs-type">block_copy_state_t</span> *copy_state,</span><br><span class="hljs-params">                                                  <span class="hljs-type">uvm_push_t</span> *push)</span><br></code></pre></td></tr></table></figure>

<h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>block</strong>：表示虚拟地址块的结构体指针。</li>
<li><strong>copy_state</strong>：表示块复制状态的结构体指针。</li>
<li><strong>push</strong>：用于推送命令的结构体指针。</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li><strong>NV_STATUS</strong>：表示操作的状态，可能的值包括 <code>NV_OK</code>（成功）或其他错误代码。</li>
</ul>
<h4 id="初始化变量-2"><a href="#初始化变量-2" class="headerlink" title="初始化变量"></a>初始化变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">NV_STATUS status;<br><span class="hljs-type">uvm_page_index_t</span> page_index;<br><span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer = copy_state-&gt;dma_buffer;<br><span class="hljs-type">uvm_page_mask_t</span> *encrypted_page_mask = &amp;dma_buffer-&gt;encrypted_page_mask;<br><span class="hljs-type">void</span> *auth_tag_buffer_base = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;auth_tag);<br><span class="hljs-type">void</span> *staging_buffer_base = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;alloc);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>初始化DMA缓冲区和相关内存地址</strong>。</li>
<li><strong>获取加密页面掩码、认证标签缓冲区基地址和暂存缓冲区基地址</strong>。</li>
</ul>
<h4 id="参数和状态验证-2"><a href="#参数和状态验证-2" class="headerlink" title="参数和状态验证"></a>参数和状态验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">UVM_ASSERT(uvm_channel_is_secure(push-&gt;channel));<br><br><span class="hljs-keyword">if</span> (UVM_ID_IS_GPU(copy_state-&gt;dst.id))<br>    <span class="hljs-keyword">return</span> NV_OK;<br><br>UVM_ASSERT(UVM_ID_IS_GPU(copy_state-&gt;src.id));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>确保推送命令的通道是安全的</strong>。</li>
<li><strong>如果目标是GPU，直接返回成功状态</strong>。</li>
<li><strong>确保源是GPU</strong>。</li>
</ul>
<h4 id="等待推送命令完成"><a href="#等待推送命令完成" class="headerlink" title="等待推送命令完成"></a>等待推送命令完成</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_push_wait(push);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>等待推送命令完成</strong>。</li>
<li><strong>如果等待失败，返回错误状态</strong>。</li>
</ul>
<h4 id="处理每个页面"><a href="#处理每个页面" class="headerlink" title="处理每个页面"></a>处理每个页面</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">for_each_va_block_page_in_mask(page_index, encrypted_page_mask, block) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">dst_page</span> =</span> uvm_cpu_chunk_get_cpu_page(block, page_index);<br>    <span class="hljs-type">void</span> *staging_buffer = (<span class="hljs-type">char</span> *)staging_buffer_base + (page_index * PAGE_SIZE);<br>    <span class="hljs-type">void</span> *auth_tag_buffer = (<span class="hljs-type">char</span> *)auth_tag_buffer_base + (page_index * UVM_CONF_COMPUTING_AUTH_TAG_SIZE);<br>    <span class="hljs-type">void</span> *cpu_page_address = kmap(dst_page);<br><br>    status = uvm_conf_computing_cpu_decrypt(push-&gt;channel,<br>                                            cpu_page_address,<br>                                            staging_buffer,<br>                                            &amp;dma_buffer-&gt;decrypt_iv[page_index],<br>                                            PAGE_SIZE,<br>                                            auth_tag_buffer);<br>    kunmap(dst_page);<br>    <span class="hljs-keyword">if</span> (status != NV_OK) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Bug 3814087: [UVM][HCC] 处理CSL认证标签验证失败和其他失败情况。</span><br>        <span class="hljs-comment">// uvm_conf_computing_cpu_decrypt() 可能因为认证标签验证失败而失败。</span><br>        <span class="hljs-comment">// 如果发生这种情况，认为是严重故障，无法恢复。</span><br>        uvm_global_set_fatal_error(status);<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>遍历加密页面掩码中的每个页面</strong>。</li>
<li><strong>获取目标页面和相关缓冲区地址</strong>。</li>
<li><strong>将页面映射到CPU地址空间</strong>。</li>
<li><strong>调用 <code>uvm_conf_computing_cpu_decrypt</code> 函数在CPU端解密页面数据</strong>。</li>
<li><strong>解除页面映射</strong>。</li>
<li><strong>如果解密失败，记录严重错误并返回错误状态</strong>。</li>
</ul>
<h4 id="中文注释-2"><a href="#中文注释-2" class="headerlink" title="中文注释"></a>中文注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 当启用机密计算功能时，该函数完成 GPU 到 CPU 的页面复制操作。</span><br><span class="hljs-comment">// GPU 操作遵守调用者在推送命令中先前设置的内存屏障。</span><br><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">conf_computing_copy_pages_finish</span><span class="hljs-params">(<span class="hljs-type">uvm_va_block_t</span> *block,</span><br><span class="hljs-params">                                                  <span class="hljs-type">block_copy_state_t</span> *copy_state,</span><br><span class="hljs-params">                                                  <span class="hljs-type">uvm_push_t</span> *push)</span><br>&#123;<br>    NV_STATUS status;<br>    <span class="hljs-type">uvm_page_index_t</span> page_index;<br>    <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer = copy_state-&gt;dma_buffer;<br>    <span class="hljs-type">uvm_page_mask_t</span> *encrypted_page_mask = &amp;dma_buffer-&gt;encrypted_page_mask;<br>    <span class="hljs-type">void</span> *auth_tag_buffer_base = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;auth_tag);<br>    <span class="hljs-type">void</span> *staging_buffer_base = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;alloc);<br><br>    UVM_ASSERT(uvm_channel_is_secure(push-&gt;channel));<br><br>    <span class="hljs-keyword">if</span> (UVM_ID_IS_GPU(copy_state-&gt;dst.id))<br>        <span class="hljs-keyword">return</span> NV_OK;<br><br>    UVM_ASSERT(UVM_ID_IS_GPU(copy_state-&gt;src.id));<br><br>    status = uvm_push_wait(push);<br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">return</span> status;<br><br>    <span class="hljs-comment">// kmap() 只保证 PAGE_SIZE 的连续性，所有加密和解密操作必须在 PAGE_SIZE 的基础上进行。</span><br>    for_each_va_block_page_in_mask(page_index, encrypted_page_mask, block) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">dst_page</span> =</span> uvm_cpu_chunk_get_cpu_page(block, page_index);<br>        <span class="hljs-type">void</span> *staging_buffer = (<span class="hljs-type">char</span> *)staging_buffer_base + (page_index * PAGE_SIZE);<br>        <span class="hljs-type">void</span> *auth_tag_buffer = (<span class="hljs-type">char</span> *)auth_tag_buffer_base + (page_index * UVM_CONF_COMPUTING_AUTH_TAG_SIZE);<br>        <span class="hljs-type">void</span> *cpu_page_address = kmap(dst_page);<br><br>        status = uvm_conf_computing_cpu_decrypt(push-&gt;channel,<br>                                                cpu_page_address,<br>                                                staging_buffer,<br>                                                &amp;dma_buffer-&gt;decrypt_iv[page_index],<br>                                                PAGE_SIZE,<br>                                                auth_tag_buffer);<br>        kunmap(dst_page);<br>        <span class="hljs-keyword">if</span> (status != NV_OK) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Bug 3814087: [UVM][HCC] 处理 CSL 认证标签验证失败和其他失败情况。</span><br>            <span class="hljs-comment">// uvm_conf_computing_cpu_decrypt() 可能因为认证标签验证失败而失败。</span><br>            <span class="hljs-comment">// 如果发生这种情况，认为是严重故障，无法恢复。</span><br>            uvm_global_set_fatal_error(status);<br>            <span class="hljs-keyword">return</span> status;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NV_OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>函数 <code>conf_computing_copy_pages_finish</code> 负责完成 GPU 到 CPU 的页面复制操作，并在 CPU 端解密这些数据。通过初始化变量和验证参数，函数确保数据传输和加密操作的正确性。遍历加密页面掩码中的每个页面，逐页解密数据，并处理可能出现的错误。在完成所有页面的处理后，函数返回成功状态。</p>
<h3 id="encrypted-memcopy-cpu-to-gpu"><a href="#encrypted-memcopy-cpu-to-gpu" class="headerlink" title="encrypted_memcopy_cpu_to_gpu"></a>encrypted_memcopy_cpu_to_gpu</h3><p>这个函数 <code>encrypted_memcopy_gpu_to_cpu</code> 实现了在 GPU 和 CPU 之间进行同步加密复制的操作。它通过 GPU 端的加密（使用复制引擎）和 CPU 端的解密，将 GPU 上的数据传输到 CPU，最终在目标 CPU 缓冲区中得到解密后的明文数据。以下是对这段代码的详细分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__attribute__ ((format(<span class="hljs-built_in">printf</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)))<br><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">encrypted_memcopy_gpu_to_cpu</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu,</span><br><span class="hljs-params">                                              <span class="hljs-type">void</span> *dst_plain,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_gpu_address_t</span> src_gpu_address,</span><br><span class="hljs-params">                                              <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_tracker_t</span> *tracker,</span><br><span class="hljs-params">                                              <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format,</span><br><span class="hljs-params">                                              ...)</span><br></code></pre></td></tr></table></figure>

<h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>gpu</strong>：指向 GPU 结构体的指针。</li>
<li><strong>dst_plain</strong>：目标 CPU 缓冲区的指针，用于存储解密后的明文数据。</li>
<li><strong>src_gpu_address</strong>：源 GPU 地址，包含需要加密的数据。</li>
<li><strong>size</strong>：需要复制的数据大小。</li>
<li><strong>tracker</strong>：用于跟踪操作的追踪器，可以为 NULL。</li>
<li><strong>format</strong>：格式化字符串，用于日志记录。</li>
<li>**…**：可变参数列表，与格式化字符串对应。</li>
</ul>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li><strong>NV_STATUS</strong>：表示操作的状态，可能的值包括 <code>NV_OK</code>（成功）或其他错误代码。</li>
</ul>
<h4 id="初始化变量和检查条件"><a href="#初始化变量和检查条件" class="headerlink" title="初始化变量和检查条件"></a>初始化变量和检查条件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">NV_STATUS status;<br>UvmCslIv decrypt_iv;<br><span class="hljs-type">uvm_push_t</span> push;<br><span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer;<br><span class="hljs-type">uvm_gpu_address_t</span> dst_gpu_address, auth_tag_gpu_address;<br><span class="hljs-type">void</span> *src_cipher, *auth_tag;<br>va_list args;<br><br>UVM_ASSERT(uvm_conf_computing_mode_enabled(gpu));<br>UVM_ASSERT(size &lt;= UVM_CONF_COMPUTING_DMA_BUFFER_SIZE);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>初始化状态变量和加密相关变量</strong>。</li>
<li><strong>检查 GPU 是否启用了机密计算模式</strong>。</li>
<li>**确保要复制的数据大小不超过最大限制 <code>UVM_CONF_COMPUTING_DMA_BUFFER_SIZE</code>**。</li>
</ul>
<h4 id="分配-DMA-缓冲区"><a href="#分配-DMA-缓冲区" class="headerlink" title="分配 DMA 缓冲区"></a>分配 DMA 缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_conf_computing_dma_buffer_alloc(&amp;gpu-&gt;conf_computing.dma_buffer_pool, &amp;dma_buffer, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>从 GPU 的 DMA 缓冲池中分配一个 DMA 缓冲区</strong>。</li>
<li><strong>如果分配失败，返回错误状态</strong>。</li>
</ul>
<h4 id="开始推送命令并记录日志"><a href="#开始推送命令并记录日志" class="headerlink" title="开始推送命令并记录日志"></a>开始推送命令并记录日志</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">va_start(args, format);<br>status = uvm_push_begin_acquire(gpu-&gt;channel_manager, UVM_CHANNEL_TYPE_GPU_TO_CPU, tracker, &amp;push, format, args);<br>va_end(args);<br><br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">goto</span> out;<br><br>uvm_conf_computing_log_gpu_encryption(push.channel, &amp;decrypt_iv);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>使用可变参数列表初始化推送命令</strong>。</li>
<li><strong>如果推送命令初始化失败，跳转到错误处理部分</strong>。</li>
<li><strong>记录 GPU 加密操作的日志</strong>。</li>
</ul>
<h4 id="设置地址并执行加密"><a href="#设置地址并执行加密" class="headerlink" title="设置地址并执行加密"></a>设置地址并执行加密</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">dst_gpu_address = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;alloc, gpu);<br>auth_tag_gpu_address = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;auth_tag, gpu);<br>gpu-&gt;parent-&gt;ce_hal-&gt;encrypt(&amp;push, dst_gpu_address, src_gpu_address, size, auth_tag_gpu_address);<br><br>status = uvm_push_end_and_wait(&amp;push);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">goto</span> out;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>设置目标 GPU 地址和认证标签地址</strong>。</li>
<li><strong>使用复制引擎在 GPU 上执行加密操作</strong>。</li>
<li><strong>等待推送命令完成</strong>。</li>
<li><strong>如果等待失败，跳转到错误处理部分</strong>。</li>
</ul>
<h4 id="获取加密数据并在-CPU-上解密"><a href="#获取加密数据并在-CPU-上解密" class="headerlink" title="获取加密数据并在 CPU 上解密"></a>获取加密数据并在 CPU 上解密</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">src_cipher = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;alloc);<br>auth_tag = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;auth_tag);<br>status = uvm_conf_computing_cpu_decrypt(push.channel, dst_plain, src_cipher, &amp;decrypt_iv, size, auth_tag);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>获取加密数据和认证标签的 CPU 地址</strong>。</li>
<li><strong>在 CPU 上执行解密操作</strong>。</li>
<li><strong>如果解密失败，跳转到错误处理部分</strong>。</li>
</ul>
<h4 id="错误处理和释放资源"><a href="#错误处理和释放资源" class="headerlink" title="错误处理和释放资源"></a>错误处理和释放资源</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">out:<br>uvm_conf_computing_dma_buffer_free(&amp;gpu-&gt;conf_computing.dma_buffer_pool, dma_buffer, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>释放分配的 DMA 缓冲区</strong>。</li>
<li><strong>返回操作状态</strong>。</li>
</ul>
<h4 id="中文注释-3"><a href="#中文注释-3" class="headerlink" title="中文注释"></a>中文注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 启动 GPU 和 CPU 之间的同步加密复制操作。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该复制操作包括 GPU 端加密（依赖于复制引擎）和 CPU 端解密步骤，</span><br><span class="hljs-comment">// 使得目标 CPU 缓冲区（由 dst_plain 指向）将包含未加密的（明文）内容。</span><br><span class="hljs-comment">// 目标缓冲区可以在受保护或未受保护的系统内存中，而源缓冲区必须在受保护的显存中。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 允许的最大复制大小是 UVM_CONF_COMPUTING_DMA_BUFFER_SIZE。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果输入追踪器不为 NULL，则由负责加密复制的推送命令内部获取。</span><br>__attribute__ ((format(<span class="hljs-built_in">printf</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)))<br><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">encrypted_memcopy_gpu_to_cpu</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu,</span><br><span class="hljs-params">                                              <span class="hljs-type">void</span> *dst_plain,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_gpu_address_t</span> src_gpu_address,</span><br><span class="hljs-params">                                              <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_tracker_t</span> *tracker,</span><br><span class="hljs-params">                                              <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format,</span><br><span class="hljs-params">                                              ...)</span><br>&#123;<br>    NV_STATUS status;<br>    UvmCslIv decrypt_iv;<br>    <span class="hljs-type">uvm_push_t</span> push;<br>    <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer;<br>    <span class="hljs-type">uvm_gpu_address_t</span> dst_gpu_address, auth_tag_gpu_address;<br>    <span class="hljs-type">void</span> *src_cipher, *auth_tag;<br>    va_list args;<br><br>    UVM_ASSERT(uvm_conf_computing_mode_enabled(gpu));<br>    UVM_ASSERT(size &lt;= UVM_CONF_COMPUTING_DMA_BUFFER_SIZE);<br><br>    status = uvm_conf_computing_dma_buffer_alloc(&amp;gpu-&gt;conf_computing.dma_buffer_pool, &amp;dma_buffer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">return</span> status;<br><br>    va_start(args, format);<br>    status = uvm_push_begin_acquire(gpu-&gt;channel_manager, UVM_CHANNEL_TYPE_GPU_TO_CPU, tracker, &amp;push, format, args);<br>    va_end(args);<br><br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    uvm_conf_computing_log_gpu_encryption(push.channel, &amp;decrypt_iv);<br><br>    dst_gpu_address = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;alloc, gpu);<br>    auth_tag_gpu_address = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;auth_tag, gpu);<br>    gpu-&gt;parent-&gt;ce_hal-&gt;encrypt(&amp;push, dst_gpu_address, src_gpu_address, size, auth_tag_gpu_address);<br><br>    status = uvm_push_end_and_wait(&amp;push);<br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    src_cipher = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;alloc);<br>    auth_tag = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;auth_tag);<br>    status = uvm_conf_computing_cpu_decrypt(push.channel, dst_plain, src_cipher, &amp;decrypt_iv, size, auth_tag);<br><br> out:<br>    uvm_conf_computing_dma_buffer_free(&amp;gpu-&gt;conf_computing.dma_buffer_pool, dma_buffer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>函数 <code>encrypted_memcopy_gpu_to_cpu</code> 实现了在 GPU 和 CPU 之间的同步加密复制操作。通过 GPU 端的加密和 CPU 端的解密，该函数确保数据在传输过程中保持机密性和完整性。通过初始化变量、分配 DMA 缓冲区、推送和等待命令、获取和解密数据，函数完成了从 GPU 到 CPU 的数据复制操作。错误处理和资源释放确保了在任何步骤失败时都能正确清理资源并返回相应的错误状态。</p>
<h3 id="encrypted-memcopy-cpu-to-gpu-1"><a href="#encrypted-memcopy-cpu-to-gpu-1" class="headerlink" title="encrypted_memcopy_cpu_to_gpu"></a>encrypted_memcopy_cpu_to_gpu</h3><p>这个函数 <code>encrypted_memcopy_cpu_to_gpu</code> 实现了在 CPU 和 GPU 之间进行同步加密复制的操作。它通过 CPU 端的加密和 GPU 端的解密，将 CPU 上的明文数据传输到 GPU，最终在目标 GPU 缓冲区中得到解密后的密文数据。以下是对这段代码的详细分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__attribute__ ((format(<span class="hljs-built_in">printf</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)))<br><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">encrypted_memcopy_cpu_to_gpu</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_gpu_address_t</span> dst_gpu_address,</span><br><span class="hljs-params">                                              <span class="hljs-type">void</span> *src_plain,</span><br><span class="hljs-params">                                              <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_tracker_t</span> *tracker,</span><br><span class="hljs-params">                                              <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format,</span><br><span class="hljs-params">                                              ...)</span><br></code></pre></td></tr></table></figure>

<h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>gpu</strong>：指向 GPU 结构体的指针。</li>
<li><strong>dst_gpu_address</strong>：目标 GPU 地址，存储解密后的密文数据。</li>
<li><strong>src_plain</strong>：源 CPU 缓冲区的指针，包含未加密的明文数据。</li>
<li><strong>size</strong>：需要复制的数据大小。</li>
<li><strong>tracker</strong>：用于跟踪操作的追踪器，可以为 NULL。</li>
<li><strong>format</strong>：格式化字符串，用于日志记录。</li>
<li>**…**：可变参数列表，与格式化字符串对应。</li>
</ul>
<h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li><strong>NV_STATUS</strong>：表示操作的状态，可能的值包括 <code>NV_OK</code>（成功）或其他错误代码。</li>
</ul>
<h4 id="初始化变量和检查条件-1"><a href="#初始化变量和检查条件-1" class="headerlink" title="初始化变量和检查条件"></a>初始化变量和检查条件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">NV_STATUS status;<br><span class="hljs-type">uvm_push_t</span> push;<br><span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer;<br><span class="hljs-type">uvm_gpu_address_t</span> src_gpu_address, auth_tag_gpu_address;<br><span class="hljs-type">void</span> *dst_cipher, *auth_tag;<br>va_list args;<br><br>UVM_ASSERT(uvm_conf_computing_mode_enabled(gpu));<br>UVM_ASSERT(size &lt;= UVM_CONF_COMPUTING_DMA_BUFFER_SIZE);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>初始化状态变量和加密相关变量</strong>。</li>
<li><strong>检查 GPU 是否启用了机密计算模式</strong>。</li>
<li>**确保要复制的数据大小不超过最大限制 <code>UVM_CONF_COMPUTING_DMA_BUFFER_SIZE</code>**。</li>
</ul>
<h4 id="分配-DMA-缓冲区-1"><a href="#分配-DMA-缓冲区-1" class="headerlink" title="分配 DMA 缓冲区"></a>分配 DMA 缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">status = uvm_conf_computing_dma_buffer_alloc(&amp;gpu-&gt;conf_computing.dma_buffer_pool, &amp;dma_buffer, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>从 GPU 的 DMA 缓冲池中分配一个 DMA 缓冲区</strong>。</li>
<li><strong>如果分配失败，返回错误状态</strong>。</li>
</ul>
<h4 id="开始推送命令并记录日志-1"><a href="#开始推送命令并记录日志-1" class="headerlink" title="开始推送命令并记录日志"></a>开始推送命令并记录日志</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">va_start(args, format);<br>status = uvm_push_begin_acquire(gpu-&gt;channel_manager, UVM_CHANNEL_TYPE_CPU_TO_GPU, tracker, &amp;push, format, args);<br>va_end(args);<br><br><span class="hljs-keyword">if</span> (status != NV_OK)<br>    <span class="hljs-keyword">goto</span> out;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>使用可变参数列表初始化推送命令</strong>。</li>
<li><strong>如果推送命令初始化失败，跳转到错误处理部分</strong>。</li>
</ul>
<h4 id="CPU-端加密操作"><a href="#CPU-端加密操作" class="headerlink" title="CPU 端加密操作"></a>CPU 端加密操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">dst_cipher = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;alloc);<br>auth_tag = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;auth_tag);<br>uvm_conf_computing_cpu_encrypt(push.channel, dst_cipher, src_plain, <span class="hljs-literal">NULL</span>, size, auth_tag);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>获取加密数据和认证标签的 CPU 地址</strong>。</li>
<li><strong>在 CPU 上执行加密操作</strong>。</li>
</ul>
<h4 id="设置地址并执行解密"><a href="#设置地址并执行解密" class="headerlink" title="设置地址并执行解密"></a>设置地址并执行解密</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">src_gpu_address = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;alloc, gpu);<br>auth_tag_gpu_address = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;auth_tag, gpu);<br>gpu-&gt;parent-&gt;ce_hal-&gt;decrypt(&amp;push, dst_gpu_address, src_gpu_address, size, auth_tag_gpu_address);<br><br>status = uvm_push_end_and_wait(&amp;push);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>设置源 GPU 地址和认证标签地址</strong>。</li>
<li><strong>使用复制引擎在 GPU 上执行解密操作</strong>。</li>
<li><strong>等待推送命令完成</strong>。</li>
</ul>
<h4 id="错误处理和释放资源-1"><a href="#错误处理和释放资源-1" class="headerlink" title="错误处理和释放资源"></a>错误处理和释放资源</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">out:<br>uvm_conf_computing_dma_buffer_free(&amp;gpu-&gt;conf_computing.dma_buffer_pool, dma_buffer, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> status;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>释放分配的 DMA 缓冲区</strong>。</li>
<li><strong>返回操作状态</strong>。</li>
</ul>
<h4 id="中文注释-4"><a href="#中文注释-4" class="headerlink" title="中文注释"></a>中文注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 启动 CPU 和 GPU 之间的同步加密复制操作。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 源 CPU 缓冲区（由 src_plain 指向）包含未加密的明文内容；</span><br><span class="hljs-comment">// 该函数在内部执行 CPU 端加密步骤，然后启动 GPU 端 CE 解密。</span><br><span class="hljs-comment">// 源缓冲区可以在受保护或未受保护的系统内存中，而目标缓冲区必须在受保护的显存中。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 允许的最大复制大小是 UVM_CONF_COMPUTING_DMA_BUFFER_SIZE。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果输入追踪器不为 NULL，则由负责加密复制的推送命令内部获取。</span><br>__attribute__ ((format(<span class="hljs-built_in">printf</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)))<br><span class="hljs-type">static</span> NV_STATUS <span class="hljs-title function_">encrypted_memcopy_cpu_to_gpu</span><span class="hljs-params">(<span class="hljs-type">uvm_gpu_t</span> *gpu,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_gpu_address_t</span> dst_gpu_address,</span><br><span class="hljs-params">                                              <span class="hljs-type">void</span> *src_plain,</span><br><span class="hljs-params">                                              <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                              <span class="hljs-type">uvm_tracker_t</span> *tracker,</span><br><span class="hljs-params">                                              <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format,</span><br><span class="hljs-params">                                              ...)</span><br>&#123;<br>    NV_STATUS status;<br>    <span class="hljs-type">uvm_push_t</span> push;<br>    <span class="hljs-type">uvm_conf_computing_dma_buffer_t</span> *dma_buffer;<br>    <span class="hljs-type">uvm_gpu_address_t</span> src_gpu_address, auth_tag_gpu_address;<br>    <span class="hljs-type">void</span> *dst_cipher, *auth_tag;<br>    va_list args;<br><br>    <span class="hljs-comment">// 确认 GPU 启用了机密计算模式</span><br>    UVM_ASSERT(uvm_conf_computing_mode_enabled(gpu));<br>    <span class="hljs-comment">// 确认数据大小不超过最大限制</span><br>    UVM_ASSERT(size &lt;= UVM_CONF_COMPUTING_DMA_BUFFER_SIZE);<br><br>    <span class="hljs-comment">// 分配 DMA 缓冲区</span><br>    status = uvm_conf_computing_dma_buffer_alloc(&amp;gpu-&gt;conf_computing.dma_buffer_pool, &amp;dma_buffer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">return</span> status;<br><br>    <span class="hljs-comment">// 初始化推送命令</span><br>    va_start(args, format);<br>    status = uvm_push_begin_acquire(gpu-&gt;channel_manager, UVM_CHANNEL_TYPE_CPU_TO_GPU, tracker, &amp;push, format, args);<br>    va_end(args);<br><br>    <span class="hljs-keyword">if</span> (status != NV_OK)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-comment">// 获取加密数据和认证标签的 CPU 地址</span><br>    dst_cipher = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;alloc);<br>    auth_tag = uvm_mem_get_cpu_addr_kernel(dma_buffer-&gt;auth_tag);<br>    <span class="hljs-comment">// 在 CPU 上执行加密操作</span><br>    uvm_conf_computing_cpu_encrypt(push.channel, dst_cipher, src_plain, <span class="hljs-literal">NULL</span>, size, auth_tag);<br><br>    <span class="hljs-comment">// 设置源 GPU 地址和认证标签地址</span><br>    src_gpu_address = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;alloc, gpu);<br>    auth_tag_gpu_address = uvm_mem_gpu_address_virtual_kernel(dma_buffer-&gt;auth_tag, gpu);<br>    <span class="hljs-comment">// 在 GPU 上执行解密操作</span><br>    gpu-&gt;parent-&gt;ce_hal-&gt;decrypt(&amp;push, dst_gpu_address, src_gpu_address, size, auth_tag_gpu_address);<br><br>    <span class="hljs-comment">// 等待推送命令完成</span><br>    status = uvm_push_end_and_wait(&amp;push);<br><br>out:<br>    <span class="hljs-comment">// 释放 DMA 缓冲区</span><br>    uvm_conf_computing_dma_buffer_free(&amp;gpu-&gt;conf_computing.dma_buffer_pool, dma_buffer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>函数 <code>encrypted_memcopy_cpu_to_gpu</code> 实现了在 CPU 和 GPU 之间的同步加密复制操作。通过 CPU 端的加密和 GPU 端的解密，该函数确保数据在传输过程中保持机密性和完整性。通过初始化变量、分配 DMA 缓冲区、推送和等待命令、获取和加密数据，函数完成了从 CPU 到 GPU 的数据复制操作。错误处理和资源释放确保了在任何步骤失败时都能正确清理资源并返回相应的错误状态。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Security/" class="category-chain-item">Security</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/GPU/" class="print-no-link">#GPU</a>
      
        <a href="/tags/TEE/" class="print-no-link">#TEE</a>
      
        <a href="/tags/Confidential-Compute/" class="print-no-link">#Confidential Compute</a>
      
        <a href="/tags/Security/" class="print-no-link">#Security</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/11/Security/Chinese-Confidential-Compute-Standard/" title="机密计算: 通用框架概要">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">机密计算: 通用框架概要</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/24/GPU/Computing-Startup/" title="GPU Computing Startup">
                        <span class="hidden-mobile">GPU Computing Startup</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Tech Odyssey</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>2024</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
<!-- hexo injector body_end start --><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d = OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:false,models:[{"path":"/live2d-models/models/umaru/model.json","position":[100,30],"scale":0.25,"stageStyle":{"width":400,"height":470}},{"path":"/live2d-models/models/kobayaxi/model.json","position":[30,0],"scale":0.3,"stageStyle":{"width":400}},{"path":"/live2d-models/models/bilibili-22/index.json","position":[0,30],"scale":0.35,"stageStyle":{"width":400}},{"path":"/live2d-models/models/bilibili-33/index.json","position":[0,30],"scale":0.35,"stageStyle":{"width":400}}],parentElement:document.body,primaryColor:"#7f6f6c",tips:{style: {"left":"calc(50%)","top":"-50px"},idleTips:{interval:150}}});</script><!-- hexo injector body_end end --></body>
</html>
